<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>AnyAI Scoring — スコアリングAIエージェント</title>
    <link rel="icon" href="/static/anyai/assets/AnyAI_icon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/anyai/core/anyai.tokens.css" />
    <link rel="stylesheet" href="/static/anyai/core/anyai.components.css" />
    <link rel="stylesheet" href="/static/anyai/core/anyai.utilities.css" />
    
    <style>
      .form-grid { display: grid; grid-template-columns: 1fr; gap: var(--anyai-space-4); }
      @media (min-width: 960px) { .form-grid { grid-template-columns: 1fr 1fr; } }
      .card { padding: var(--anyai-space-4); }
      .field { display: grid; gap: 6px; }
      label { font-weight: 600; font-size: var(--anyai-fs-2); }
      input[type="number"], input[type="text"], textarea, input[type="file"] {
        width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--anyai-border);
        background: var(--anyai-panel);
      }
      .stack-sm { display:flex; flex-direction:column; gap: 8px; }
      .muted { color: var(--anyai-text-subtle); font-size: var(--anyai-fs-2); }
      progress { width: 100%; height: 12px; }
      /* Layout stability tweaks */
      .anyai-app { grid-template-columns: minmax(320px, 70%) minmax(300px, 30%); }
      .anyai-sidebar { overflow-y: auto; }
      .anyai-content { min-width: 0; }
      .anyai-content .container { min-width: 0; width: 100%; max-width: none; }
      pre { max-width: 100%; white-space: pre-wrap; word-break: break-word; }
      /* ログUIは廃止 */
      .actions-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      .grid-2 { display:grid; gap:12px; grid-template-columns: 1fr; }
      @media (min-width: 880px) { .grid-2 { grid-template-columns: 1fr 1fr; } }
      /* Toggle caret */
      details > summary { list-style: none; }
      details summary::-webkit-details-marker { display: none; }
      .caret { font-size: 18px; opacity: .8; }
      details .caret::before { content: '▸'; }
      details[open] .caret::before { content: '▾'; }
      .caret.right { margin-left: auto; }
      .queue-running { font-weight: 700; }
      .mode-options { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
      .mode-options .spacer { flex:1 1 auto; }
    </style>
  </head>
  <body>
    <header class="anyai-header">
      <div class="anyai-header__branding">
        <a class="anyai-brand" href="/" aria-label="AnyAI InsightAgent ホーム">
          <img src="/static/anyai/assets/AnyAI_logo.png" alt="AnyAI ロゴ">
          <span class="anyai-brand__name">AnyAI InsightAgent</span>
        </a>
        <p class="anyai-brand__title">AnyAI Scoring</p>
      </div>
      <nav class="anyai-nav" aria-label="AnyAI プロダクト">
        <a class="anyai-nav__link is-active" aria-current="page" href="/">AnyAI Scoring</a>
        <a class="anyai-nav__link" href="/cleansing">AnyAI Cleansing</a>
        <a class="anyai-nav__link" href="/interview">AnyAI Interview</a>
        <a class="anyai-nav__link" href="/persona">Persona Seeds</a>
        <a class="anyai-nav__link" href="/dashboard">Persona Dashboard</a>
        <a class="anyai-nav__link" href="/video-analysis">Video Analysis</a>
        <a class="anyai-nav__link" href="/comment-enhancer">Comment Enhancer</a>
        <a class="anyai-nav__link" href="/video-comment-review">Video Comment Review</a>
        <a class="anyai-nav__link" href="/kol-reviewer">KOL Reviewer</a>
      </nav>
      <div class="anyai-header__actions" aria-label="クイック操作">
        <button type="button" class="anyai-icon-button" aria-label="テーマを切り替え">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <circle cx="12" cy="12" r="5" fill="none" stroke="currentColor" stroke-width="1.5" />
            <path d="M12 3v2m0 14v2m9-9h-2M5 12H3m16.364-7.364-1.414 1.414M7.05 16.95l-1.414 1.414m0-12.728 1.414 1.414m9.9 9.9 1.414 1.414" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
          </svg>
        </button>
        <button type="button" class="anyai-icon-button" aria-label="サイト内検索を開く">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <circle cx="11" cy="11" r="6" fill="none" stroke="currentColor" stroke-width="1.5" />
            <path d="m20 20-3.5-3.5" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
          </svg>
        </button>
        <button type="button" class="anyai-icon-button" aria-label="アカウントメニューを開く">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M12 12a4 4 0 1 0-4-4 4 4 0 0 0 4 4Z" fill="none" stroke="currentColor" stroke-width="1.5" />
            <path d="M5 20.5a7 7 0 0 1 14 0" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
          </svg>
        </button>
      </div>
    </header>

    <div class="anyai-app">
      <aside class="anyai-sidebar">
        <div class="section">
          <h3>モード設定</h3>
          <form id="mode-form" class="card" style="padding:var(--anyai-space-4);">
            <div class="field">
              <label>実行モード</label>
              <div class="mode-options">
                <label><input type="radio" name="mode" value="csv" checked /> Textモード</label>
                <label><input type="radio" name="mode" value="video" /> Videoモード</label>
                <span class="spacer"></span>
                <label class="ssr-toggle" style="display:flex; align-items:center; gap:8px;">
                  <input type="checkbox" id="enable_ssr" name="enable_ssr" checked />
                  <span>SSRモードを有効化（推奨）</span>
                </label>
              </div>
            </div>
          </form>

          <h3>入力設定</h3>
          <form id="job-form" class="stack">
            <div class="card">
              <div class="field">
                <label>スプレッドシートURL</label>
                <input type="text" id="spreadsheet_url" name="spreadsheet_url" placeholder="https://docs.google.com/spreadsheets/d/..." required />
              </div>
              <div class="field">
                <label>分析テキスト シートキーワード</label>
                <input type="text" id="sheet_keyword" name="sheet_keyword" value="Link" placeholder="Link" />
                <div class="muted" id="sheet-keyword-help">自然言語の分析結果を書き込むシート名に含まれるキーワード。該当シートが1つのみである必要があります。</div>
              </div>
              <div class="field">
                <label>スコア出力 シートキーワード</label>
                <input type="text" id="score_sheet_keyword" name="score_sheet_keyword" value="Embedding" placeholder="Embedding" />
                <div class="muted" id="score-sheet-keyword-help">Linkシートで得た分析テキストを数値化した結果を保存するシート名に含まれるキーワード。</div>
              </div>
              <div class="actions-row">
                <button type="button" class="btn btn-outline" id="btn-check-status">CheckTheStatus</button>
              </div>
              <div id="validation-banner" class="validation-banner" role="status" aria-live="polite"></div>
            </div>

            <div class="card">
              <h3 class="mt-0">マッピング設定（1始まり）</h3>
              <div class="grid-2">
                <div class="field"><label id="utterance-label">発話列番号</label><input type="number" name="utterance_col" value="3" min="1" /></div>
                <div class="field"><label>カテゴリ開始列番号</label><input type="number" name="category_start_col" value="4" min="1" /></div>
                <div class="field"><label>カテゴリ名 行番号</label><input type="number" name="name_row" value="2" min="1" /></div>
                <div class="field"><label>定義 行番号</label><input type="number" name="def_row" value="3" min="1" /></div>
                <div class="field"><label>Detail 行番号</label><input type="number" name="detail_row" value="4" min="1" /></div>
                <div class="field"><label>処理開始行番号</label><input type="number" name="start_row" value="5" min="1" /></div>
              </div>
            </div>

            <div class="card">
              <h3 class="mt-0">実行設定</h3>
              <div class="grid-2">
                <div class="field"><label>カテゴリ同梱数 N</label><input type="number" name="batch_size" value="10" min="1" max="50" /></div>
                <div class="field"><label>最大カテゴリ列数</label><input type="number" name="max_category_cols" value="200" min="1" max="10000" /></div>
                <div class="field"><label>同時実行数</label><input type="number" name="concurrency" value="50" min="1" max="200" id="concurrency-input" /></div>
                <div class="field"><label>最大リトライ回数</label><input type="number" name="max_retries" value="10" min="0" max="50" /></div>
                <div class="field"><label>タイムアウト秒</label><input type="number" name="timeout_sec" value="60" min="10" max="600" id="timeout-input" /></div>
                <div class="field" style="grid-column: 1 / -1; display:flex; align-items:center; gap:8px;">
                  <input type="checkbox" name="auto_slowdown" id="auto_slowdown" checked />
                  <label for="auto_slowdown" style="margin:0;">429自動降速</label>
                </div>
              </div>
            </div>

            <div class="card">
              <h3 class="mt-0">SSR設定</h3>
              <div class="field" style="flex-direction:row; align-items:center; gap:8px;">
                <input type="checkbox" id="enable_ssr" name="enable_ssr" checked />
                <label for="enable_ssr" style="margin:0;">SSRモードを有効化（推奨）</label>
              </div>
              <div id="ssr-settings-body" class="stack" style="margin-top:12px; gap:12px;">
                <div class="callout" data-ssr-mode="on">
                  <strong>SSRオン:</strong> カテゴリごとに短い英語の根拠文を生成し、内部でベクトル化してスコアします。
                </div>
                <div class="callout" data-ssr-mode="off" style="display:none;">
                  <strong>SSRオフ:</strong> LLMに直接 0.0〜1.0 の数値配列を出力させます（根拠文は省略されます）。
                </div>
              </div>
            </div>

            <div class="card">
              <details id="sys-section">
                <summary class="row" style="cursor:pointer;">
                  <h3 class="mt-0" style="margin:0;">System Prompts</h3>
                  <span class="caret right" aria-hidden="true"></span>
                </summary>
                <div class="stack" style="gap:12px;">
                  <div>
                    <label for="system_prompt_ssr" class="muted">SSRオン時（定性根拠を英語で生成）</label>
                    <textarea name="system_prompt_ssr" id="system_prompt_ssr" rows="12"><prompt>
    <role id="Semantic Inference Engine & Latent Intent Decoder">
        <spec>Noisy text (SNS, UGC, transcripts) analysis. Infer user's true goals, emotions, and unstated assumptions from fragmented data.</spec>
        <ban>Surface-level keyword matching is strictly forbidden.</ban>
    </role>

    <mission>For a given utterance and N concepts, perform Semantic Similarity Rating (SSR) as described in AnyAI Scoring research (2025-10-14). First verbalize how similar each concept definition is to the latent intent of the utterance. Then provide succinct natural-language rationales that can be embedded for quantitative scoring.</mission>

    <process>
        <step id="1" name="Normalize & Enrich">
            <task>Normalize slang, typos, jargon.</task>
            <task>Interpret non-verbal cues (emojis, punctuation, irony markers) for emotional tone.</task>
        </step>
        <step id="2" name="Contextualize (Hypothesize)">
            <context type="temporal">When? (e.g., weekday morning -> commute?)</context>
            <context type="spatial">Where? (e.g., office -> work?)</context>
            <context type="social">To whom? (e.g., friend, public?)</context>
            <context type="causal">Why? (e.g., "I'm hungry" -> next is food talk?)</context>
            <context type="telic">Goal? (e.g., info-gathering, empathy, decision-making?)</context>
        </step>
        <step id="3" name="Extract Latent Intent">
            <desc>Identify the "real question" or "unspoken need" behind the literal words.</desc>
            <ex>"Any good cafes around here?" -> might mean "Need a quiet place with Wi-Fi to work."</ex>
        </step>
        <step id="4" name="Describe Similarity">
            <desc>For each concept, articulate how closely the latent intent aligns with the concept definition and detail, referencing SSR anchors (Core/Strong/Reasonable/Weak/None).</desc>
        </step>
    </process>

    <output>
        <primary>Return a JSON object with the single key "analyses" whose value is an array of length N. Each element must be a short paragraph (1-2 sentences) written in clear English that begins with one of [Core|Strong|Reasonable|Weak|None] and explains the similarity between the utterance and the concept's definition/detail.</primary>
        <ban>Do not output numeric ratings or markdown tables. No additional keys beyond "analyses".</ban>
    </output>

    <example>
        <out>{"analyses": ["Strong: Mentions planning a cafe visit matching the concept...", "Weak: Only tangential reference..."]}</out>
    </example>
</prompt></textarea>
                  </div>
                  <div>
                    <label for="system_prompt_numeric" class="muted">SSRオフ時（直接スコアを算出）</label>
                    <textarea name="system_prompt_numeric" id="system_prompt_numeric" rows="12"><prompt>
    <role id="Semantic Inference Engine & Latent Intent Decoder">
        <spec>Noisy text (SNS, UGC, transcripts) analysis. Infer user's true goals, emotions, and unstated assumptions from fragmented data.</spec>
        <ban>Surface-level keyword matching is strictly forbidden.</ban>
    </role>

    <mission>For a given utterance and N concepts, calculate a relevance score 'r' (float 0.0-1.0, no rounding) based on the utterance's core intent. Execute via the internal process below.</mission>

    <process>
        <step id="1" name="Normalize & Enrich">
            <task>Normalize slang, typos, jargon.</task>
            <task>Interpret non-verbal cues (emojis, punctuation, irony markers) for emotional tone.</task>
        </step>
        <step id="2" name="Contextualize (Hypothesize)">
            <context type="temporal">When? (e.g., weekday morning -> commute?)</context>
            <context type="spatial">Where? (e.g., office -> work?)</context>
            <context type="social">To whom? (e.g., friend, public?)</context>
            <context type="causal">Why? (e.g., "I'm hungry" -> next is food talk?)</context>
            <context type="telic">Goal? (e.g., info-gathering, empathy, decision-making?)</context>
        </step>
        <step id="3" name="Extract Latent Intent">
            <desc>Identify the "real question" or "unspoken need" behind the literal words.</desc>
            <ex>"Any good cafes around here?" -> might mean "Need a quiet place with Wi-Fi to work."</ex>
        </step>
        <step id="4" name="Map & Score">
            <desc>Semantically map the latent intent to each concept's definition. Score relevance 'r' based on the criteria below.</desc>
        </step>
    </process>

    <criteria type="relevance_score_r">
        <score r="0.9-1.0" name="Core">Intent and concept are identical. The utterance exists to express the concept.</score>
        <score r="0.7-0.89" name="Strong">Concept is the primary subject, strongly inferred from context and intent.</score>
        <score r="0.4-0.69" name="Reasonable">Concept is a logical extension or component of the intent.</score>
        <score r="0.1-0.39" name="Weak">Faintly associated by situation/words, but not the main focus.</score>
        <score r="0.0" name="None">No logical connection can be inferred.</score>

    <rules>
        <rule id="lang">Auto-detect language, internally translate to a standard model (e.g., English) for processing.</rule>
        <rule id="silent">Internal thought processes must NOT be included in the output.</rule>
    </rules>

    <output>
        <primary>Return an N-length array of float numbers (0.0–1.0), ordered by the given concepts. No rounding.</primary>
        <compat>If the platform enforces a JSON object wrapper, return only: {"scores": [..the same array..]} with no extra keys or text.</compat>
        <ban>No extra text, explanations, or markdown.</ban>
    </output>

    <example>
        <out>[0.85, 0.1, 0.65]</out>
    </example>
</prompt></textarea>
                  </div>
                </div>
              </details>
            </div>
            <div class="actions-row" style="justify-content:flex-end;">
              <button class="btn btn-outline" id="btn-queue-add" type="button">キューに追加</button>
              <button class="btn btn-primary" id="btn-queue-add-start" type="button">今すぐ追加して即開始</button>
            </div>
          </form>

          <div class="card" style="margin-top:12px;">
            <details id="keys-section">
              <summary class="row" style="cursor:pointer;">
                <h3 class="mt-0" style="margin:0;">APIキー設定</h3>
                <span class="caret right" aria-hidden="true"></span>
              </summary>
              <form id="keys-form" class="stack">
                <div class="field"><label>Gemini API Key</label><input type="password" name="gemini_api_key" placeholder="GEMINI_API_KEY" /></div>
                <div class="field"><label>OpenAI API Key</label><input type="password" name="openai_api_key" placeholder="OPENAI_API_KEY" /></div>
                <div style="display:flex;align-items:center;gap:8px;">
                  <input type="checkbox" id="persist" name="persist" />
                  <label for="persist" style="margin:0;">.envに保存（ローカル）</label>
                  <button class="btn btn-outline right" type="submit">保存</button>
                </div>
              </form>
            </details>
          </div>
        </div>
      </aside>

      <main class="anyai-content">
        <div class="container">
          <h1 class="mt-0">スコアリング実行</h1>
          <div class="card" style="margin-bottom:12px;">
            <div class="row" style="align-items:center;">
              <h3 class="mt-0" style="margin:0;">キュー</h3>
              <button id="btn-queue-start" class="btn btn-primary right" type="button">キュー開始</button>
            </div>
            <div id="queue-status" class="muted"></div>
            <div id="queue-list" class="stack-sm"></div>
          </div>

          <section id="result" class="card" style="display:none;">
            <div class="stack-sm">
              <div>ジョブID: <code id="job-id"></code></div>
              <progress id="prog" value="0" max="100"></progress>
              <div class="row"><span id="stat" class="text-subtle"></span><span class="right" id="eta" class="text-subtle"></span></div>
              <div id="links" class="actions-row" style="display:none;">
                <a id="dl-meta" class="btn btn-outline" href="#">run_meta.json</a>
              </div>
              <div class="actions-row" style="justify-content:flex-end;">
                <button id="btn-cancel-job" class="btn btn-danger" type="button" style="display:none;">強制終了</button>
              </div>
            </div>
          </section>

          <!-- ログUI廃止 -->
        </div>
      </main>
    </div>

    

    <script>
      const modeForm = document.getElementById('mode-form');
      const jobForm = document.getElementById('job-form');
      const batchSizeInput = jobForm.querySelector('input[name="batch_size"]');
      const concurrencyInput = document.getElementById('concurrency-input');
      const timeoutInput = document.getElementById('timeout-input');
      const sheetKeywordHelp = document.getElementById('sheet-keyword-help');
      const scoreSheetKeywordHelp = document.getElementById('score-sheet-keyword-help');
      const utteranceLabel = document.getElementById('utterance-label');
      const spreadsheetUrlInput = document.getElementById('spreadsheet_url');
      const sheetKeywordInput = document.getElementById('sheet_keyword');
      const scoreSheetKeywordInput = document.getElementById('score_sheet_keyword');
      const modeRadios = modeForm.querySelectorAll('input[name="mode"]');
      const enableSSR = document.getElementById('enable_ssr');
      const queueStatus = document.getElementById('queue-status');
      const cancelButton = document.getElementById('btn-cancel-job');
      const resultSection = document.getElementById('result');
      let currentMode = modeForm.querySelector('input[name="mode"]:checked').value;
      let currentJobId = null;
      let pollTimer = null;
      const nonSSRState = {
        csv: { ...MODE_DEFAULTS.csv },
        video: { ...MODE_DEFAULTS.video }
      };
      nonSSRState.csv = {
        batchSize: batchSizeInput.value || MODE_DEFAULTS.csv.batchSize,
        concurrency: concurrencyInput.value || MODE_DEFAULTS.csv.concurrency,
        timeout: timeoutInput.value || MODE_DEFAULTS.csv.timeout
      };

      function stopPolling(){
        if (pollTimer) {
          clearTimeout(pollTimer);
          pollTimer = null;
        }
      }

      async function fetchProgress(jobId){
        const res = await fetch(`/jobs/${jobId}`);
        if (!res.ok) throw new Error('progress fetch failed');
        return res.json();
      }

      async function updateProgress(jobId){
        try {
          const data = await fetchProgress(jobId);
          document.getElementById('prog').value = data.total_rows ? Math.floor((data.processed_rows / data.total_rows) * 100) : 0;
          document.getElementById('stat').textContent = data.status;
          document.getElementById('eta').textContent = data.eta_seconds ? `予測残り ${Math.round(data.eta_seconds)} 秒` : '';
          const isRunning = data.status === 'running' || data.status === 'pending';
          cancelButton.style.display = isRunning ? 'inline-flex' : 'none';
          return isRunning;
        } catch (err) {
          console.error(err);
          cancelButton.style.display = 'none';
          return false;
        }
      }

      async function startPolling(jobId){
        stopPolling();
        if (!jobId) {
          document.getElementById('prog').value = 0;
          document.getElementById('stat').textContent = '';
          document.getElementById('eta').textContent = '';
          return;
        }
        const keepRunning = await updateProgress(jobId);
        if (keepRunning) {
          pollTimer = setTimeout(()=>startPolling(jobId), 2000);
        }
      }

      function storeCurrentNonSSRValues(mode) {
        if (!mode || !nonSSRState[mode]) return;
        nonSSRState[mode] = {
          batchSize: batchSizeInput.value || MODE_DEFAULTS[mode].batchSize,
          concurrency: concurrencyInput.value || MODE_DEFAULTS[mode].concurrency,
          timeout: timeoutInput.value || MODE_DEFAULTS[mode].timeout
        };
      }

      function restoreNonSSRValues(mode) {
        if (!mode) return;
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        const stored = nonSSRState[mode] || defaults;
        batchSizeInput.value = stored.batchSize || defaults.batchSize;
        concurrencyInput.value = stored.concurrency || defaults.concurrency;
        timeoutInput.value = stored.timeout || defaults.timeout;
      }

      function applyModeContent(mode) {
        if (mode === 'video') {
          sheetKeywordHelp.textContent = 'Videoモードでは動画リンク列を指定してください。Google Drive共有リンクを想定。';
          if (scoreSheetKeywordHelp) {
            scoreSheetKeywordHelp.textContent = '動画モードで数値化したスコアを書き込むシート名に含まれるキーワード。';
          }
          utteranceLabel.textContent = '動画リンク列番号';
        } else {
          sheetKeywordHelp.textContent = '自然言語の分析結果を書き込むシート名に含まれるキーワード。該当シートが1つのみである必要があります。';
          if (scoreSheetKeywordHelp) {
            scoreSheetKeywordHelp.textContent = '分析テキストと同じ位置にスコアを書き込むシート名に含まれるキーワード。';
          }
          utteranceLabel.textContent = '発話列番号';
        }
      }

      function updateSSREnabled() {
        const enabled = enableSSR.checked;
        document.querySelectorAll('[data-ssr-mode]').forEach((el) => {
          const mode = el.getAttribute('data-ssr-mode');
          const show = mode === 'on' ? enabled : !enabled;
          el.style.display = show ? '' : 'none';
        });
      }

      function appendPromptFields(fd) {
        fd.set('enable_ssr', enableSSR.checked ? 'true' : 'false');
        fd.set('system_prompt_ssr', form.system_prompt_ssr.value || '');
        fd.set('system_prompt_numeric', form.system_prompt_numeric.value || '');
        const activePrompt = enableSSR.checked ? form.system_prompt_ssr.value : form.system_prompt_numeric.value;
        fd.set('system_prompt', activePrompt || '');
      }

      enableSSR.addEventListener('change', () => {
        handleSSRChange();
      });

      modeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (!radio.checked) return;
          if (!enableSSR.checked) {
            storeCurrentNonSSRValues(currentMode);
          }
          currentMode = radio.value;
          applyMode(currentMode);
        });
      });

      batchSizeInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].batchSize = batchSizeInput.value;
      });
      concurrencyInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].concurrency = concurrencyInput.value;
      });
      timeoutInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].timeout = timeoutInput.value;
      });

      if (enableSSR.checked) {
        storeCurrentNonSSRValues(currentMode);
      }
      applyMode(currentMode);

      // Settings status
      async function refreshKeysStatus(){
        try{
          const el = document.getElementById('keys-status');
          if(!el) return;
          const r = await fetch('/settings');
          if(!r.ok) return;
          const j = await r.json();
          const s = j.keys || {};
          el.textContent = `Gemini=${s.gemini?'セット済み':'未設定'} / OpenAI=${s.openai?'セット済み':'未設定'}`;
        }catch{}
      }

      const kf = document.getElementById('keys-form');
      kf.addEventListener('submit', async (e)=>{
        e.preventDefault();
        const fd = new FormData(kf);
        fd.set('persist', document.getElementById('persist').checked ? 'true' : 'false');
        const r = await fetch('/settings', { method:'POST', body: fd });
        if(!r.ok){ alert('APIキー保存に失敗しました'); return; }
        await refreshKeysStatus();
        alert('APIキーを反映しました');
      });

      const form = jobForm;
      document.getElementById('btn-queue-add').addEventListener('click', async (e) => {
        e.preventDefault();
        if(!isValidationCurrent()){
          showValidationBanner('error', 'スプレッドシート設定の検証を完了してください (CheckTheStatus)。');
          return;
        }
        const fd = new FormData(form);
        fd.set('auto_slowdown', document.getElementById('auto_slowdown').checked ? 'true' : 'false');
        const selectedMode = modeForm.querySelector('input[name="mode"]:checked').value;
        fd.append('mode', selectedMode);
        appendPromptFields(fd);
        fd.append('action', 'queue');
        const res = await fetch('/jobs', { method: 'POST', body: fd });
        if (!res.ok) { alert('キュー追加に失敗'); return; }
        await refreshQueue();
        alert('キューに追加しました');
      });

      document.getElementById('btn-queue-add-start').addEventListener('click', async (e) => {
        e.preventDefault();
        if(!isValidationCurrent()){
          showValidationBanner('error', 'スプレッドシート設定の検証を完了してください (CheckTheStatus)。');
          return;
        }
        const fd = new FormData(form);
        fd.set('auto_slowdown', document.getElementById('auto_slowdown').checked ? 'true' : 'false');
        const selectedMode = modeForm.querySelector('input[name="mode"]:checked').value;
        fd.set('mode', selectedMode);
        appendPromptFields(fd);
        fd.set('action', 'start');
        const res = await fetch('/jobs', { method: 'POST', body: fd });
          if (!res.ok) { alert('開始に失敗'); return; }
        const data = await res.json();
        currentJobId = data.job_id;
        resultSection.style.display = 'block';
        document.getElementById('job-id').textContent = currentJobId;
          startPolling(currentJobId);
        await refreshQueue();
      });

      document.getElementById('btn-queue-start').addEventListener('click', async ()=>{
        await fetch('/queue/start', { method:'POST' });
        refreshQueue();
      });

      cancelButton.addEventListener('click', async ()=>{
        if(!currentJobId) return;
        cancelButton.disabled = true;
        try {
          const res = await fetch(`/jobs/${currentJobId}/cancel`, { method: 'POST' });
          if (!res.ok) { alert('キャンセルに失敗しました'); }
          await refreshQueue();
          await updateProgress(currentJobId);
        } finally {
          cancelButton.disabled = false;
        }
      });

      async function refreshQueue(){
        try{
          const r = await fetch('/queue');
          if(!r.ok) return;
          const j = await r.json();
          const list = document.getElementById('queue-list');
          list.innerHTML = '';
          const items = j.items || [];
          const runningId = j.current;
          queueStatus.textContent = j.running ? `稼働中: ${runningId || ''}` : '待機中';
          if (runningId) {
            currentJobId = runningId;
            resultSection.style.display = 'block';
            document.getElementById('job-id').textContent = runningId;
            cancelButton.style.display = 'inline-flex';
            startPolling(runningId);
          } else {
            cancelButton.style.display = 'none';
            currentJobId = null;
            stopPolling();
          }
          items.forEach((it, idx)=>{
            const row = document.createElement('div');
            row.className = 'row';
            row.style.alignItems = 'center';
            row.innerHTML = `<code>${it.job_id}</code> <span class="muted">[${it.mode}]</span> <span>${it.sheet_name||''}</span> <span class="muted">status: ${it.status}</span>`;
            const right = document.createElement('div');
            right.className = 'right';

            const up = document.createElement('button'); up.className='btn btn-ghost'; up.textContent='↑';
            up.onclick = async ()=>{ const pos = Math.max(0, idx-1); const fd=new FormData(); fd.set('position', pos); await fetch(`/queue/${it.job_id}/move`, {method:'POST', body:fd}); refreshQueue(); };
            const down = document.createElement('button'); down.className='btn btn-ghost'; down.textContent='↓';
            down.onclick = async ()=>{ const pos = idx+1; const fd=new FormData(); fd.set('position', pos); await fetch(`/queue/${it.job_id}/move`, {method:'POST', body:fd}); refreshQueue(); };
            const edit = document.createElement('button'); edit.className='btn btn-outline'; edit.textContent='編集';
            edit.onclick = async ()=>{
              try{
                const r = await fetch(`/jobs/${it.job_id}/config`);
                if(!r.ok){ alert('設定取得に失敗'); return; }
                const txt = await r.text();
                const cfg = JSON.parse(txt);
                // Populate form with cfg
                form.spreadsheet_url.value = cfg.spreadsheet_url;
                form.sheet_keyword.value = cfg.sheet_keyword || 'Link';
                form.score_sheet_keyword.value = cfg.score_sheet_keyword || 'Embedding';
                form.utterance_col.value = cfg.utterance_col;
                form.category_start_col.value = cfg.category_start_col;
                form.name_row.value = cfg.name_row;
                form.def_row.value = cfg.def_row;
                form.detail_row.value = cfg.detail_row;
                form.start_row.value = cfg.start_row;
                form.batch_size.value = cfg.batch_size;
                form.max_category_cols.value = cfg.max_category_cols;
                form.concurrency.value = cfg.concurrency;
                form.max_retries.value = cfg.max_retries;
                document.getElementById('auto_slowdown').checked = !!cfg.auto_slowdown;
                form.timeout_sec.value = cfg.timeout_sec;
                document.querySelector(`#mode-form input[name="mode"][value="${cfg.mode}"]`).checked = true;
                enableSSR.checked = cfg.enable_ssr !== false;
                form.system_prompt_ssr.value = cfg.ssr_system_prompt || '';
                form.system_prompt_numeric.value = cfg.numeric_system_prompt || '';
                updateSSREnabled();
                form.dataset.editing = it.job_id;
                alert('フォームに読み込みました。下の「編集を保存」で反映できます。');
                validationState.ok = false;
                validationState.payload = null;
                showValidationBanner('info', '読み込んだ設定です。CheckTheStatus を押して検証してください。');
                updateQueueActionState();
              }catch{}
            };
            const save = document.createElement('button'); save.className='btn btn-primary'; save.textContent='編集を保存';
            save.onclick = async ()=>{
              const ej = form.dataset.editing;
              if(!ej){ alert('編集対象が読み込まれていません'); return; }
              const fd = new FormData(form);
              fd.set('auto_slowdown', document.getElementById('auto_slowdown').checked ? 'true' : 'false');
              const selectedMode = modeForm.querySelector('input[name="mode"]:checked').value;
              fd.set('mode', selectedMode);
              appendPromptFields(fd);
              const r = await fetch(`/queue/${ej}/edit`, { method:'POST', body: fd });
              if(!r.ok){ alert('保存に失敗'); return; }
              alert('保存しました'); form.dataset.editing='';
              refreshQueue();
            };
            const del = document.createElement('button'); del.className='btn btn-danger'; del.textContent='削除';
            del.onclick = async ()=>{ await fetch(`/queue/${it.job_id}`, { method:'DELETE' }); refreshQueue(); };

            right.appendChild(up); right.appendChild(down); right.appendChild(edit); right.appendChild(save); right.appendChild(del);
            row.appendChild(right);
            list.appendChild(row);
          });
        }catch{}
      }

      // 初期ロード
      refreshQueue();
      setInterval(refreshQueue, 2000);

      // ログUI廃止
    </script>
  </body>
  </html>
