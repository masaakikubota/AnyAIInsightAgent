<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>AnyAI Scoring — スコアリングAIエージェント</title>
    <link rel="icon" href="/static/anyai/assets/AnyAI_Logo_For_Loading.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/anyai/css/main.css" />
    <script src="/static/anyai/loading-overlay.js"></script>
    <script defer src="/static/anyai/vendor/lucide.js"></script>
    <script defer src="/static/anyai/sidebar.js"></script>
    
    <style>
      .mode-options {
        display: inline-flex;
        align-items: center;
        gap: var(--anyai-space-2);
        margin-bottom: var(--anyai-space-3);
      }

      .mode-divider {
        width: 1px;
        align-self: stretch;
        background: color-mix(in srgb, var(--anyai-border), transparent 20%);
      }

      .mode-pill {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--anyai-space-2);
        padding: 0.45rem 1rem;
        border-radius: 999px;
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 20%);
        background: linear-gradient(135deg,
          color-mix(in srgb, #ffffff, var(--anyai-border) 4%),
          color-mix(in srgb, #ffffff, var(--anyai-border) 12%)
        );
        color: color-mix(in srgb, var(--anyai-text), transparent 25%);
        font-weight: 600;
        cursor: pointer;
        transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease,
          box-shadow 0.2s ease, transform 0.15s ease;
        user-select: none;
      }

      .mode-pill input[type="radio"] {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        border: 0;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(100%);
        overflow: hidden;
        white-space: nowrap;
      }

      .mode-pill span {
        font-size: var(--anyai-fs-2);
        line-height: 1;
      }

      .mode-pill:not([aria-checked="true"]) {
        border-color: color-mix(in srgb, var(--anyai-border), transparent 30%);
      }

      .mode-pill:not([aria-checked="true"]):hover {
        border-color: color-mix(in srgb, var(--anyai-border), var(--anyai-primary, #2955ff) 28%);
        color: color-mix(in srgb, var(--anyai-text), transparent 10%);
        background: linear-gradient(135deg,
          color-mix(in srgb, #ffffff, var(--anyai-primary, #2955ff) 12%),
          color-mix(in srgb, #ffffff, var(--anyai-primary, #2955ff) 20%)
        );
      }

      .mode-pill:focus-within {
        outline: none;
        box-shadow: 0 0 0 2px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 75%);
      }

      .mode-pill[aria-checked="true"] {
        background: linear-gradient(135deg,
          color-mix(in srgb, var(--anyai-primary, #2955ff), white 12%),
          color-mix(in srgb, var(--anyai-primary, #2955ff), black 6%)
        );
        border-color: color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 12%);
        color: #ffffff;
        box-shadow:
          0 0 0 3px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 80%),
          0 12px 28px rgba(41, 85, 255, 0.25);
        transform: translateY(-1px);
      }

      .mode-ssr {
        display: inline-flex;
        align-items: center;
        gap: var(--anyai-space-2);
        font-weight: 600;
      }

      .mode-ssr span:first-of-type {
        font-weight: 600;
      }

      .mode-ssr-hint {
        font-weight: 400;
        font-size: var(--anyai-fs-2);
        color: var(--anyai-text-subtle);
      }

      .toggle-switch {
        position: relative;
        display: inline-flex;
        align-items: center;
        width: 48px;
        height: 26px;
        border-radius: 999px;
        cursor: pointer;
        transition: box-shadow 0.2s ease;
        flex: 0 0 auto;
        min-width: 48px;
      }

      .toggle-switch input[type="checkbox"] {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        border: 0;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(100%);
        overflow: hidden;
        white-space: nowrap;
      }

      .toggle-switch .toggle-knob {
        position: absolute;
        top: 3px;
        left: 3px;
        right: auto;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #ffffff;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.2);
        transition: transform 0.2s ease, left 0.2s ease, right 0.2s ease;
      }

      .toggle-switch input[type="checkbox"]:checked ~ .toggle-knob {
        left: auto;
        right: 3px;
        transform: none;
      }

      .toggle-switch input[type="checkbox"]:checked ~ .toggle-track {
        background: var(--anyai-primary, #2955ff);
        border-color: var(--anyai-primary, #2955ff);
        box-shadow: 0 0 0 3px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 82%);
      }

      .toggle-switch:focus-within {
        box-shadow: 0 0 0 3px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 80%),
          0 8px 18px rgba(41, 85, 255, 0.2);
      }

      .toggle-switch .toggle-track {
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: color-mix(in srgb, var(--anyai-border), transparent 35%);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 25%);
        transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      }

      #scoring-heading {
        margin-bottom: 0;
      }

      .anyai-form-section {
        display: flex;
        flex-direction: column;
        gap: var(--anyai-space-3, 12px);
        background: var(--anyai-form-band, #f1f5f9);
        border-radius: var(--anyai-radius-2, 12px);
        padding: var(--anyai-space-5, 20px) var(--anyai-space-6, 28px);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 85%);
      }

      .anyai-form-section + .anyai-form-section {
        margin-top: 0;
      }

      .anyai-form-group {
        display: flex;
        flex-direction: column;
        gap: var(--anyai-space-3, 12px);
        background: none;
        border: 0;
        border-radius: 0;
        padding: 0;
      }

      .anyai-form-section > header,
      .anyai-form-group > header {
        margin-bottom: 0;
      }

      .anyai-form-section > header > h2.mt-0,
      .anyai-form-group > header > h3.mt-0 {
        margin-bottom: 0;
      }

      .field-with-action {
        display: flex;
        align-items: stretch;
        gap: 0;
      }

      .field-with-action input[type="text"] {
        flex: 1 1 auto;
        min-width: 0;
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
        border-right: 0;
      }

      .field-with-action .input-action-btn {
        flex: 0 0 auto;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0 var(--anyai-space-4, 16px);
        min-width: 72px;
        border-radius: 0 var(--anyai-radius-2, 12px) var(--anyai-radius-2, 12px) 0;
        border-left: 0;
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
        font-weight: 600;
        transition: transform 0.15s ease, box-shadow 0.2s ease, background-color 0.2s ease;
      }

      .field-with-action .input-action-btn:not(.btn-soft-accent) {
        border: none;
        box-shadow: 0 4px 10px rgba(31, 36, 50, 0.12);
      }

      .field-with-action .input-action-btn:not(.btn-soft-accent):hover,
      .field-with-action .input-action-btn:not(.btn-soft-accent):focus-visible {
        box-shadow: 0 6px 16px rgba(31, 36, 50, 0.16);
        outline: none;
      }

      .field-with-action .input-action-btn.btn-soft-accent:hover,
      .field-with-action .input-action-btn.btn-soft-accent:focus-visible {
        transform: translateY(-1px);
      }

      .field-with-action .input-action-btn.btn-soft-accent {
        border-left: 0;
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
      }

.anyai-form-fields {
  gap: var(--anyai-space-3, 12px);
}

.field .field-hint {
  margin-top: var(--anyai-space-1, 4px);
}

.sheet-selection-grid {
  width: 100%;
  grid-template-columns: minmax(0, 1fr);
  gap: var(--anyai-space-3);
  align-items: start;
}

      .sheet-selection-grid > .field:first-of-type {
        grid-column: 1 / -1;
      }

.sheet-selection-grid details.field-info-inline .info-panel {
  width: 100%;
  box-sizing: border-box;
  font-size: var(--anyai-fs-1);
}

      .sheet-selection-grid .field {
        position: relative;
      }

      .sheet-selection-grid .field select {
        width: 100%;
        border-radius: var(--anyai-radius-2);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 20%);
        background:
          url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'%3E%3Cpath fill='none' stroke='%23545d72' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2' d='m3 5 4 4 4-4'/%3E%3C/svg%3E")
            right 12px center / 14px 14px no-repeat,
          #ffffff;
        padding: 6px 40px 6px 12px;
        font: inherit;
        line-height: 1.4;
        color: inherit;
        appearance: none;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease,
          color 0.2s ease;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.02);
      }

      .sheet-selection-grid .field select:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background:
          url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'%3E%3Cpath fill='none' stroke='%238490a8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2' d='m3 5 4 4 4-4'/%3E%3C/svg%3E")
            right 12px center / 14px 14px no-repeat,
          #f5f7fb;
        color: color-mix(in srgb, currentColor, transparent 25%);
        border-color: color-mix(in srgb, var(--anyai-border), transparent 10%);
      }

      .sheet-selection-grid .field select:not(:disabled):hover {
        border-color: color-mix(in srgb, var(--anyai-border), var(--anyai-primary, #2955ff) 28%);
        box-shadow: 0 4px 10px rgba(36, 43, 68, 0.06);
      }

      .sheet-selection-grid .field select:not(:disabled):focus-visible {
        outline: none;
        border-color: color-mix(in srgb, var(--anyai-border), var(--anyai-primary, #2955ff) 40%);
        box-shadow:
          0 0 0 4px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 85%),
          0 6px 18px rgba(36, 43, 68, 0.08);
      }

      .sheet-selection-grid .field select option,
      .sheet-selection-grid .field select optgroup {
        background: #ffffff;
        color: var(--anyai-text, #1f2432);
      }

      .custom-select {
        position: relative;
        width: 100%;
      }

      .custom-select-native {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        border: 0;
        clip: rect(0 0 0 0);
        clip-path: inset(100%);
        overflow: hidden;
        white-space: nowrap;
      }

      .custom-select-toggle {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--anyai-space-3);
        padding: 6px 40px 6px 12px;
        border-radius: var(--anyai-radius-2);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 20%);
        background: #ffffff;
        color: var(--anyai-text, #1f2432);
        font: inherit;
        line-height: 1.4;
        cursor: pointer;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
        position: relative;
      }

      .custom-select-toggle::after {
        content: "";
        width: 14px;
        height: 14px;
        flex: 0 0 auto;
        background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'%3E%3Cpath fill='none' stroke='%23545d72' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2' d='m3 5 4 4 4-4'/%3E%3C/svg%3E") center / contain no-repeat;
        transition: transform 0.2s ease;
        position: absolute;
        right: 16px;
        top: 50%;
        transform: translateY(-50%);
      }

      .custom-select-label {
        flex: 1 1 auto;
        text-align: left;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding-right: var(--anyai-space-2);
      }

      .custom-select.is-open .custom-select-toggle {
        border-radius: var(--anyai-radius-2) var(--anyai-radius-2) 0 0;
        border-color: color-mix(in srgb, var(--anyai-border), var(--anyai-primary, #2955ff) 40%);
        box-shadow:
          0 0 0 4px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 85%),
          0 10px 30px rgba(36, 43, 68, 0.08);
      }

      .custom-select.is-open .custom-select-toggle::after {
        transform: rotate(180deg);
      }

      .custom-select:not(.has-value) .custom-select-label {
        color: color-mix(in srgb, var(--anyai-text), transparent 35%);
      }

      .custom-select.is-disabled .custom-select-toggle {
        cursor: not-allowed;
        background: #f5f7fb;
        color: color-mix(in srgb, var(--anyai-text), transparent 35%);
      }

      .custom-select.is-disabled .custom-select-toggle::after {
        filter: grayscale(1) opacity(0.65);
      }

      .custom-select-menu {
        position: absolute;
        left: 0;
        top: calc(100% - 1px);
        width: 100%;
        background: #ffffff;
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 20%);
        border-top: 0;
        border-radius: 0 0 var(--anyai-radius-2) var(--anyai-radius-2);
        box-shadow: 0 22px 40px rgba(36, 43, 68, 0.16);
        max-height: 280px;
        overflow-y: auto;
        padding: 4px 0;
        z-index: 70;
        opacity: 0;
        pointer-events: none;
        transform: translateY(6px);
        transition: opacity 0.18s ease, transform 0.18s ease;
      }

      .custom-select.is-open .custom-select-menu {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0);
      }

      .custom-select-option {
        display: flex;
        align-items: center;
        width: 100%;
        padding: 10px 14px;
        background: transparent;
        border: 0;
        font: inherit;
        color: inherit;
        text-align: left;
        cursor: pointer;
        transition: background-color 0.15s ease, color 0.15s ease;
      }

      .custom-select-option:hover,
      .custom-select-option:focus-visible {
        outline: none;
        background: color-mix(in srgb, var(--anyai-primary), transparent 90%);
      }

      .custom-select-option.is-selected {
        background: color-mix(in srgb, var(--anyai-primary), transparent 85%);
        font-weight: 600;
      }

      .custom-select-option.is-disabled {
        color: color-mix(in srgb, var(--anyai-text), transparent 45%);
        cursor: not-allowed;
      }

      .custom-select-option.is-disabled:hover {
        background: transparent;
      }

      .sheet-selection-grid .field details.field-info-inline {
        margin-top: var(--anyai-space-2);
      }

      .sheet-selection-grid .field details.field-info-inline .info-panel {
        margin-top: 0;
        padding: var(--anyai-space-3) var(--anyai-space-4);
        border-radius: 0 0 var(--anyai-radius-2) var(--anyai-radius-2);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 25%);
        border-top: 0;
        background: #ffffff;
        box-shadow: 0 16px 30px rgba(36, 43, 68, 0.12);
      }

      .sheet-selection-grid .field details.field-info-inline[open] .info-toggle-icon {
        background: var(--anyai-primary, #4a63ff);
        color: var(--anyai-text-inverse, #ffffff);
      }

      .sheet-selection-grid .field .field-hint {
        margin-top: var(--anyai-space-1);
      }

      @media (min-width: 960px) {
        .sheet-selection-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .sheet-selection-grid > .field:first-of-type {
          grid-column: 1 / -1;
        }
      }

      .anyai-form-actions {
        margin-top: var(--anyai-space-8);
        display: flex;
        flex-wrap: wrap;
        gap: var(--anyai-space-3);
        justify-content: center;
        align-items: center;
      }

      .anyai-form-actions .btn {
        min-width: 120px;
      }

      .anyai-action-bar {
        transition: opacity 0.2s ease, transform 0.2s ease;
        left: 50%;
        right: auto;
        bottom: clamp(var(--anyai-space-6, 24px), 6vw, var(--anyai-space-9, 64px));
        transform: translate(-50%, 0);
        justify-content: center;
        padding: var(--anyai-space-2, 8px) var(--anyai-space-3, 12px);
        gap: var(--anyai-space-2, 8px);
      }

      .anyai-action-bar.is-hidden {
        opacity: 0;
        pointer-events: none;
        transform: translate(-50%, 16px);
      }

      .anyai-action-bar.is-empty {
        display: none;
      }

      @media (max-width: 720px) {
        .anyai-form-actions {
          flex-direction: column;
          align-items: stretch;
        }

        .anyai-form-actions .btn {
          width: 100%;
        }
      }

.mapping-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: var(--anyai-space-3);
}

      .stack-sm { display: flex; flex-direction: column; gap: var(--anyai-space-3); }
      .muted { color: var(--anyai-text-subtle); font-size: var(--anyai-fs-2); }

      input[type="number"],
      input[type="text"],
      input[type="password"],
      input[type="file"],
      textarea {
        width: 100%;
        padding: 6px 10px;
        border-radius: var(--anyai-radius-2);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 30%);
        background: var(--anyai-panel);
        font: inherit;
      }

      textarea { min-height: 160px; resize: vertical; }

      progress {
        width: 100%;
        height: 12px;
        border-radius: var(--anyai-radius-2);
        overflow: hidden;
      }

      .validation-banner {
        display: none;
        padding: var(--anyai-space-3) var(--anyai-space-4);
        border-radius: var(--anyai-radius-2);
        font-size: var(--anyai-fs-2);
        font-weight: 600;
      }

      .validation-banner[data-state] { display: block; }
      .validation-banner[data-state="error"] {
        background: color-mix(in srgb, var(--anyai-danger), transparent 80%);
        color: var(--anyai-danger);
      }
      .validation-banner[data-state="success"] {
        background: color-mix(in srgb, var(--anyai-success), transparent 82%);
        color: var(--anyai-success);
      }
      .validation-banner[data-state="info"] {
        background: color-mix(in srgb, var(--anyai-primary), transparent 88%);
        color: var(--anyai-primary-700);
      }

      .queue-toast {
        position: fixed;
        top: clamp(16px, 4vw, 40px);
        left: 50%;
        transform: translate(-50%, -140%);
        opacity: 0;
        pointer-events: none;
        padding: var(--anyai-space-4) var(--anyai-space-5);
        border-radius: var(--anyai-radius-2);
        font-size: var(--anyai-fs-2);
        font-weight: 600;
        background: #ffffff;
        color: var(--anyai-text, #1f2432);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 18%);
        border-left: 4px solid var(--queue-toast-accent, var(--anyai-primary, #2955ff));
        box-shadow: 0 16px 40px rgba(15, 23, 42, 0.18);
        min-width: min(360px, calc(100vw - 32px));
        max-width: calc(100vw - 32px);
        text-align: center;
        z-index: 120;
        transition: transform 0.25s ease, opacity 0.25s ease;
      }

      .queue-toast.is-visible {
        transform: translate(-50%, 0);
        opacity: 1;
        pointer-events: auto;
      }

      .queue-toast[data-state="success"] {
        --queue-toast-accent: var(--anyai-success, #12a150);
      }

      .queue-toast[data-state="error"] {
        --queue-toast-accent: var(--anyai-danger, #d14343);
      }

      .queue-status {
        display: flex;
        align-items: center;
        gap: var(--anyai-space-2);
        font-size: var(--anyai-fs-2);
      }

      .queue-status-label {
        color: var(--anyai-text-subtle);
        font-weight: 600;
      }

      .queue-chip {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 2px 12px;
        border-radius: 999px;
        font-size: var(--anyai-fs-1);
        font-weight: 600;
        line-height: 1.2;
        border: 1px solid transparent;
      }

      .queue-chip--idle {
        background: transparent;
        border-color: transparent;
        color: color-mix(in srgb, var(--anyai-text), transparent 35%);
        padding: 0;
      }

      .queue-chip--active {
        background: color-mix(in srgb, var(--anyai-primary), transparent 82%);
        border-color: color-mix(in srgb, var(--anyai-primary), transparent 58%);
        color: color-mix(in srgb, var(--anyai-primary), black 18%);
      }

      .queue-status-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        flex: 0 0 auto;
      }

      .queue-status-dot--idle {
        background: color-mix(in srgb, #fcbf49, transparent 30%);
        box-shadow: 0 0 0 3px color-mix(in srgb, #fcbf49, transparent 70%);
      }

      @keyframes queue-status-pulse {
        0% { box-shadow: 0 0 0 0 rgba(18, 161, 80, 0.28); }
        70% { box-shadow: 0 0 0 6px rgba(18, 161, 80, 0); }
        100% { box-shadow: 0 0 0 0 rgba(18, 161, 80, 0); }
      }

      .queue-status-dot--active {
        background: var(--anyai-success, #12a150);
        animation: queue-status-pulse 1.8s ease-out infinite;
      }

      .queue-actions {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .queue-edit-button,
      .queue-save-button {
        position: relative;
      }

      .queue-edit-button {
        z-index: 2;
        font-size: 1.2rem;
        line-height: 1;
        letter-spacing: -2px;
      }

      .queue-save-button {
        box-shadow: 0 6px 18px rgba(45, 91, 255, 0.18);
      }

      .queue-save-button:hover,
      .queue-save-button:focus-visible {
        box-shadow: 0 8px 20px rgba(45, 91, 255, 0.18);
      }

      .queue-save-button[aria-busy="true"] {
        box-shadow: 0 6px 16px rgba(45, 91, 255, 0.16);
      }

      .queue-delete-button {
        box-shadow: 0 6px 18px rgba(209, 67, 67, 0.18);
      }

      .queue-delete-button:hover,
      .queue-delete-button:focus-visible {
        box-shadow: 0 8px 22px rgba(209, 67, 67, 0.2);
      }

      .queue-delete-button[aria-busy="true"] {
        box-shadow: 0 6px 16px rgba(209, 67, 67, 0.16);
      }

      .queue-save-button {
        z-index: 1;
      }

      .actions-row { display: flex; gap: var(--anyai-space-3); flex-wrap: wrap; align-items: center; }
      .band-title { margin: 0; font-size: var(--anyai-fs-3); font-weight: 600; }
      .callout {
        border-radius: var(--anyai-radius-2);
        padding: var(--anyai-space-3) var(--anyai-space-4);
        background: color-mix(in srgb, var(--anyai-primary), transparent 88%);
        font-size: var(--anyai-fs-2);
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.2rem 0.85rem;
        border-radius: 999px;
        font-size: var(--anyai-fs-2);
        font-weight: 600;
        border: 1px solid transparent;
      }
      .status-badge[data-state="success"] {
        background: color-mix(in srgb, var(--anyai-success), transparent 82%);
        color: var(--anyai-success);
        border-color: color-mix(in srgb, var(--anyai-success), transparent 65%);
      }
      .status-badge[data-state="error"] {
        background: color-mix(in srgb, var(--anyai-danger), transparent 82%);
        color: var(--anyai-danger);
        border-color: color-mix(in srgb, var(--anyai-danger), transparent 65%);
      }
      .status-badge[data-state="info"] {
        background: linear-gradient(135deg,
          color-mix(in srgb, #fce9b5, transparent 20%),
          color-mix(in srgb, #fdecc3, transparent 10%)
        );
        color: color-mix(in srgb, #c68a20, black 5%);
        border-color: color-mix(in srgb, #f7d494, transparent 45%);
      }

      .validation-meta {
        margin-top: var(--anyai-space-3);
        display: flex;
        flex-direction: column;
        gap: var(--anyai-space-2);
      }
      .validation-meta-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--anyai-space-2);
        font-size: var(--anyai-fs-2);
      }
      .validation-meta-label {
        color: var(--anyai-text-subtle);
        font-weight: 600;
      }

      .log-viewer {
        max-height: 240px;
        width: 100%;
        padding: var(--anyai-space-3) var(--anyai-space-4);
        background: color-mix(in srgb, var(--anyai-bg-subtle, #f1f5f9), transparent 20%);
        border-radius: var(--anyai-radius-2);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 10%);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.72rem;
        line-height: 1.3;
        color: var(--anyai-text);
        white-space: pre-wrap;
        word-break: break-word;
        overflow: auto;
      }

      .support-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--anyai-space-3);
      }

      .support-header h2 { margin: 0; font-size: var(--anyai-fs-4); }

      details.section-toggle > summary {
        display: flex;
        align-items: center;
        gap: var(--anyai-space-3);
        cursor: pointer;
        list-style: none;
      }

      details.section-toggle > summary::-webkit-details-marker { display: none; }
      .caret {
        margin-left: auto;
        align-self: center;
        display: inline-block;
        width: 0;
        height: 0;
        border-left: 6px solid transparent;
        border-right: 6px solid transparent;
        border-top: 8px solid currentColor;
        opacity: 0.8;
        transform: rotate(0deg);
        transform-origin: center;
        transition: transform 0.2s ease;
      }
      details[open] .caret { transform: rotate(180deg); }

      pre { max-width: 100%; white-space: pre-wrap; word-break: break-word; }
    </style>
  </head>
  <body>
    <div class="anyai-layout">
      <aside class="anyai-sidebar" data-active-tool="scoring"></aside>
      <main class="anyai-content">
        <div class="anyai-app">
          <section class="anyai-app-primary" aria-labelledby="scoring-heading">
            <h1 id="scoring-heading" class="mt-0 page-title-with-icon">
              <span class="page-title-icon" aria-hidden="true"><i data-lucide="sparkles"></i></span>
              <span>スコアリング実行</span>
            </h1>
            <p class="field-hint">スプレッドシートから概念ごとのスコアを一括で生成します。</p>

            <div class="anyai-form" aria-labelledby="scoring-config-heading">
              <section class="anyai-form-section" aria-labelledby="mode-heading">
                <header>
                  <h2 id="mode-heading" class="mt-0">モード設定</h2>
                  <p class="field-hint">処理対象のメディアとSSRモードを切り替えます。</p>
                </header>
                <form id="mode-form">
                  <fieldset class="field">
                    <legend class="sr-only">実行モード</legend>
                    <div class="mode-options" role="radiogroup" aria-label="モード選択">
                      <label class="mode-pill" data-mode="csv" role="radio" aria-checked="true" tabindex="0">
                        <input type="radio" name="mode" value="csv" checked />
                        <span>Textモード</span>
                      </label>
                      <label class="mode-pill" data-mode="video" role="radio" aria-checked="false" tabindex="-1">
                        <input type="radio" name="mode" value="video" />
                        <span>Videoモード</span>
                      </label>
                      <span class="mode-divider" aria-hidden="true"></span>
                      <label class="mode-ssr">
                        <span>SSRモード</span>
                        <span class="toggle-switch" role="switch" aria-checked="true" tabindex="0">
                          <input type="checkbox" id="enable_ssr" name="enable_ssr" checked />
                          <span class="toggle-track"></span>
                          <span class="toggle-knob"></span>
                        </span>
                        <span class="mode-ssr-hint">（推奨）</span>
                      </label>
                      <span class="spacer"></span>
                    </div>
                  </fieldset>
                </form>
              </section>

              <section class="anyai-form-section" aria-labelledby="input-heading">
                <header>
                  <h2 id="input-heading" class="mt-0">入力設定</h2>
                  <p class="field-hint">スコアリング対象となるスプレッドシートと列情報を設定します。</p>
                </header>
                <form id="job-form">
                  <div class="anyai-form-fields sheet-selection-grid">
                    <div class="field">
                      <label for="spreadsheet_url">スプレッドシートURL / ID</label>
                      <p class="field-hint">対象のGoogleシートURLまたはIDを入力し、Setでシート一覧を読み込みます。</p>
                      <div class="field-with-action">
                        <input type="text" id="spreadsheet_url" name="spreadsheet_url" placeholder="https://docs.google.com/spreadsheets/d/..." required />
                        <button type="button" class="btn btn-primary input-action-btn" id="btn-spreadsheet-set">Set</button>
                      </div>
                    </div>
                    <div class="field" id="analysis-sheet-field">
                      <label for="sheet_keyword">分析テキスト シート</label>
                      <select id="sheet_keyword" name="sheet_keyword" disabled data-placeholder="Setで読み込んでください" class="js-custom-select">
                        <option value="">Setで読み込んでください</option>
                      </select>
                      <p class="field-hint">Setで取得したシート一覧から選択します。</p>
                      <details class="field-info field-info-inline">
                        <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                        <div class="info-panel" id="sheet-keyword-help">Setで取得したシート一覧から選択します。自然言語の分析結果を書き込むシートを選択してください。</div>
                      </details>
                    </div>
                    <div class="field" id="score-sheet-field">
                      <label for="score_sheet_keyword">スコア出力 シート</label>
                      <select id="score_sheet_keyword" name="score_sheet_keyword" disabled data-placeholder="Setで読み込んでください" class="js-custom-select">
                        <option value="">Setで読み込んでください</option>
                      </select>
                      <p class="field-hint">Setで取得したシート一覧からスコアを書き込むシートを選択します。</p>
                      <details class="field-info field-info-inline">
                        <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                        <div class="info-panel" id="score-sheet-keyword-help">Setで取得したシート一覧からスコアを書き込むシートを選択します。分析結果のスコアを書き込むシートを選択してください。</div>
                      </details>
                    </div>
                    <input type="hidden" id="sheet_gid" name="sheet_gid" value="" />
                    <input type="hidden" id="score_sheet_gid" name="score_sheet_gid" value="" />
                  </div>
                  <div id="validation-banner" class="validation-banner" role="status" aria-live="polite"></div>

                  <div class="anyai-form-group" aria-labelledby="mapping-heading">
                    <h3 id="mapping-heading" class="band-title">マッピング設定（1始まり）</h3>
                    <div class="mapping-grid">
                      <div class="field"><label id="utterance-label" for="utterance_col">発話列番号</label><input type="number" name="utterance_col" id="utterance_col" value="3" min="1" /></div>
                      <div class="field"><label for="category_start_col">カテゴリ開始列番号</label><input type="number" name="category_start_col" id="category_start_col" value="4" min="1" /></div>
                      <div class="field"><label for="start_row">処理開始行番号</label><input type="number" name="start_row" id="start_row" value="5" min="1" /></div>
                      <div class="field"><label for="name_row">Name 行番号</label><input type="number" name="name_row" id="name_row" value="2" min="1" /></div>
                      <div class="field"><label for="def_row">Definition 行番号</label><input type="number" name="def_row" id="def_row" value="3" min="1" /></div>
                      <div class="field"><label for="detail_row">Detail 行番号</label><input type="number" name="detail_row" id="detail_row" value="4" min="1" /></div>
                    </div>
                  </div>

                  <div class="anyai-form-group" aria-labelledby="execution-heading">
                    <h3 id="execution-heading" class="band-title">実行設定</h3>
                    <div class="anyai-form-fields is-two-column">
                      <div class="field"><label for="batch_size">カテゴリ同梱数 N</label><input type="number" name="batch_size" id="batch_size" value="10" min="1" max="50" />
                        <p class="field-hint">SSRオン/オフに関わらず任意の数値を設定できます。</p>
                      </div>
                      <div class="field"><label for="max_category_cols">最大カテゴリ列数</label><input type="number" name="max_category_cols" id="max_category_cols" value="200" min="1" max="10000" />
                        <p class="field-hint">Videoモードでも複数列を一度にスコアリングできます（N設定に応じます）。</p>
                      </div>
                      <div class="field"><label for="concurrency-input">同時実行数</label><input type="number" name="concurrency" value="50" min="1" max="200" id="concurrency-input" /></div>
                      <div class="field"><label for="max_retries">最大リトライ回数</label><input type="number" name="max_retries" id="max_retries" value="3" min="0" max="50" /></div>
                      <div class="field"><label for="timeout-input">タイムアウト秒</label><input type="number" name="timeout_sec" value="60" min="10" max="600" id="timeout-input" /></div>
                      <div class="field">
                        <label for="primary_model">メインモデル</label>
                      <select id="primary_model" name="primary_model" class="js-custom-select" data-placeholder="モデルを選択">
                        <optgroup label="Gemini">
                          <option value="gemini-flash-lite-latest" selected>Gemini Flash Lite (latest)</option>
                          <option value="gemini-flash-latest">Gemini Flash (latest)</option>
                          <option value="gemini-pro-latest">Gemini Pro (latest)</option>
                        </optgroup>
                        <optgroup label="OpenAI">
                          <option value="gpt-5-nano">GPT-5 Nano</option>
                          <option value="gpt-4.1-nano">GPT-4.1 Nano</option>
                        </optgroup>
                      </select>
                        <p class="field-hint">テキストモードでは Gemini Flash Lite が推奨です。</p>
                      </div>
                      <div class="field" id="fallback-model-field">
                        <label for="fallback_model">フォールバックモデル</label>
                        <select id="fallback_model" name="fallback_model" class="js-custom-select" data-placeholder="フォールバックモデルを選択">
                          <optgroup label="OpenAI">
                            <option value="gpt-5-nano" selected>GPT-5 Nano</option>
                            <option value="gpt-4.1-nano">GPT-4.1 Nano</option>
                          </optgroup>
                          <optgroup label="Gemini">
                            <option value="gemini-flash-lite-latest">Gemini Flash Lite (latest)</option>
                            <option value="gemini-flash-latest">Gemini Flash (latest)</option>
                          </optgroup>
                        </select>
                        <p class="field-hint">Videoモードでは自動的に非表示になります。</p>
                      </div>
                      <div class="field field-inline"><input type="checkbox" name="auto_slowdown" id="auto_slowdown" checked /><label for="auto_slowdown">429自動降速</label></div>
                    </div>
                  </div>

                  <div class="anyai-form-group" aria-labelledby="ssr-heading">
                    <h3 id="ssr-heading" class="band-title">SSR設定</h3>
                    <div id="ssr-settings-body" class="stack">
                      <div class="callout" data-ssr-mode="on">
                        <strong>SSRオン:</strong> カテゴリごとに短い英語の根拠文を生成し、内部でベクトル化してスコアします。
                      </div>
                      <div class="callout" data-ssr-mode="off" style="display:none;">
                        <strong>SSRオフ:</strong> LLMに直接 0.0〜1.0 の数値配列を出力させます（根拠文は省略されます）。
                      </div>
                    </div>
                  </div>
                </form>
              </section>

              <section class="anyai-form-section" aria-labelledby="prompt-heading">
                <details id="sys-section" class="section-toggle">
                  <summary>
                    <h2 id="prompt-heading" class="mt-0">System Prompts</h2>
                    <span class="caret" aria-hidden="true"></span>
                  </summary>
                  <div class="stack">
                    <div>
                      <label for="system_prompt_ssr" class="muted">SSRオン時（定性根拠を英語で生成）</label>
                      <textarea name="system_prompt_ssr" id="system_prompt_ssr" rows="12"><prompt>
    <role id="Semantic Inference Engine & Latent Intent Decoder">
        <spec>Noisy text (SNS, UGC, transcripts) analysis. Infer user's true goals, emotions, and unstated assumptions from fragmented data.</spec>
        <ban>Surface-level keyword matching is strictly forbidden.</ban>
    </role>

    <mission>For a given utterance and N concepts, perform Semantic Similarity Rating (SSR) as described in AnyAI Scoring research (2025-10-14). First verbalize how similar each concept definition is to the latent intent of the utterance. Then provide succinct natural-language rationales that can be embedded for quantitative scoring.</mission>

    <process>
        <step id="1" name="Normalize & Enrich">
            <task>Normalize slang, typos, jargon.</task>
            <task>Interpret non-verbal cues (emojis, punctuation, irony markers) for emotional tone.</task>
        </step>
        <step id="2" name="Contextualize (Hypothesize)">
            <context type="temporal">When? (e.g., weekday morning -> commute?)</context>
            <context type="spatial">Where? (e.g., office -> work?)</context>
            <context type="social">To whom? (e.g., friend, public?)</context>
            <context type="causal">Why? (e.g., "I'm hungry" -> next is food talk?)</context>
            <context type="telic">Goal? (e.g., info-gathering, empathy, decision-making?)</context>
        </step>
        <step id="3" name="Extract Latent Intent">
            <desc>Identify the "real question" or "unspoken need" behind the literal words.</desc>
            <ex>"Any good cafes around here?" -> might mean "Need a quiet place with Wi-Fi to work."</ex>
        </step>
        <step id="4" name="Describe Similarity">
            <desc>For each concept, articulate how closely the latent intent aligns with the concept definition and detail, referencing SSR anchors (Core/Strong/Reasonable/Weak/None).</desc>
        </step>
    </process>

    <output>
        <primary>Return a JSON object with the single key "analyses" whose value is an array of length N. Each element must be a short paragraph (1-2 sentences) written in clear English that begins with one of [Core|Strong|Reasonable|Weak|None] and explains the similarity between the utterance and the concept's definition/detail.</primary>
        <ban>Do not output numeric ratings or markdown tables. No additional keys beyond "analyses".</ban>
    </output>

    <example>
        <out>{"analyses": ["Strong: Mentions planning a cafe visit matching the concept...", "Weak: Only tangential references..."]}</out>
    </example>
</prompt></textarea>
                    </div>
                    <div>
                      <label for="system_prompt_numeric" class="muted">SSRオフ時（直接スコアを算出）</label>
                      <textarea name="system_prompt_numeric" id="system_prompt_numeric" rows="12"><prompt>
    <role id="Semantic Inference Engine & Latent Intent Decoder">
        <spec>Noisy text (SNS, UGC, transcripts) analysis. Infer user's true goals, emotions, and unstated assumptions from fragmented data.</spec>
        <ban>Surface-level keyword matching is strictly forbidden.</ban>
    </role>

    <mission>For a given utterance and N concepts, calculate a relevance score 'r' (float 0.0-1.0, no rounding) based on the utterance's core intent. Execute via the internal process below.</mission>

    <process>
        <step id="1" name="Normalize & Enrich">
            <task>Normalize slang, typos, jargon.</task>
            <task>Interpret non-verbal cues (emojis, punctuation, irony markers) for emotional tone.</task>
        </step>
        <step id="2" name="Contextualize (Hypothesize)">
            <context type="temporal">When? (e.g., weekday morning -> commute?)</context>
            <context type="spatial">Where? (e.g., office -> work?)</context>
            <context type="social">To whom? (e.g., friend, public?)</context>
            <context type="causal">Why? (e.g., "I'm hungry" -> next is food talk?)</context>
            <context type="telic">Goal? (e.g., info-gathering, empathy, decision-making?)</context>
        </step>
        <step id="3" name="Extract Latent Intent">
            <desc>Identify the "real question" or "unspoken need" behind the literal words.</desc>
            <ex>"Any good cafes around here?" -> might mean "Need a quiet place with Wi-Fi to work."</ex>
        </step>
        <step id="4" name="Map & Score">
            <desc>Semantically map the latent intent to each concept's definition. Score relevance 'r' based on the criteria below.</desc>
        </step>
    </process>

    <criteria type="relevance_score_r">
        <score r="0.9-1.0" name="Core">Intent and concept are identical. The utterance exists to express the concept.</score>
        <score r="0.7-0.89" name="Strong">Concept is the primary subject, strongly inferred from context and intent.</score>
        <score r="0.4-0.69" name="Reasonable">Concept is a logical extension or component of the intent.</score>
        <score r="0.1-0.39" name="Weak">Faintly associated by situation/words, but not the main focus.</score>
        <score r="0.0" name="None">No logical connection can be inferred.</score>

    <rules>
        <rule id="lang">Auto-detect language, internally translate to a standard model (e.g., English) for processing.</rule>
        <rule id="silent">Internal thought processes must NOT be included in the output.</rule>
    </rules>

    <output>
        <primary>Return an N-length array of float numbers (0.0–1.0), ordered by the given concepts. No rounding.</primary>
        <compat>If the platform enforces a JSON object wrapper, return only: {"scores": [..the same array..]} with no extra keys or text.</compat>
        <ban>No extra text, explanations, or markdown.</ban>
    </output>

    <example>
        <out>[0.85, 0.1, 0.65]</out>
    </example>
</prompt></textarea>
                    </div>
                  </div>
                </details>
              </section>

              <section class="anyai-form-section" aria-labelledby="keys-heading">
                <details id="keys-section" class="section-toggle">
                  <summary>
                    <h2 id="keys-heading" class="mt-0">APIキー設定</h2>
                    <span class="caret" aria-hidden="true"></span>
                  </summary>
                  <form id="keys-form" class="stack">
                    <div class="field"><label for="gemini_api_key">Gemini API Key</label><input type="password" name="gemini_api_key" id="gemini_api_key" placeholder="GEMINI_API_KEY" /></div>
                    <div class="field"><label for="openai_api_key">OpenAI API Key</label><input type="password" name="openai_api_key" id="openai_api_key" placeholder="OPENAI_API_KEY" /></div>
                    <div class="field field-inline">
                      <input type="checkbox" id="persist" name="persist" />
                      <label for="persist">.envに保存（ローカル）</label>
                      <button class="btn btn-outline right" type="submit">保存</button>
                    </div>
                  </form>
                </details>
              </section>

              <div class="anyai-form-actions" id="scoring-action-area">
                <button type="button" class="btn btn-soft-accent" id="btn-check-status">CheckSheetInfo</button>
                <button type="button" class="btn btn-secondary btn-strong-accent" id="btn-queue-add-action" style="display:none;">Add to Queue</button>
                <button type="button" class="btn btn-primary" id="btn-queue-add-start" style="display:none;">Run</button>
              </div>
            </div>
          </section>

          <aside class="anyai-app-support">
            <div class="anyai-support-card support-metrics">
              <div class="support-header">
                <h2 class="mt-0">ジョブキュー</h2>
                <button id="btn-queue-start" class="btn btn-primary" type="button">キュー開始</button>
              </div>
              <div id="queue-status" class="queue-status"></div>
              <div id="queue-list" class="stack-sm"></div>
            </div>

            <div id="validation-status-card" class="anyai-support-card" style="display:none;">
              <div class="support-header">
                <h2 class="mt-0">検証状況</h2>
                <span id="validation-status-badge" class="status-badge" data-state="info">待機中</span>
              </div>
              <p id="validation-status-message" class="muted" role="status" aria-live="polite"></p>
              <div id="validation-status-meta" class="validation-meta"></div>
            </div>

            <div id="job-log-card" class="anyai-support-card">
              <div class="support-header">
                <h2 class="mt-0">実行ログ</h2>
                <button type="button" class="btn btn-soft-accent" id="btn-log-refresh">更新</button>
              </div>
              <pre id="job-log-content" class="log-viewer" tabindex="0">ジョブを開始するとログが表示されます。</pre>
            </div>

            <section id="result" class="anyai-support-card" style="display:none;">
              <div class="stack-sm">
                <div>ジョブID: <code id="job-id"></code></div>
                <progress id="prog" value="0" max="100"></progress>
                <div class="row"><span id="stat" class="text-subtle"></span><span class="right" id="eta"></span></div>
                <div id="links" class="actions-row" style="display:none;">
                  <a id="dl-meta" class="btn btn-outline" href="#">run_meta.json</a>
                </div>
                <div class="actions-row" style="justify-content:flex-end;">
                  <button id="btn-cancel-job" class="btn btn-danger" type="button" style="display:none;">強制終了</button>
                </div>
              </div>
            </section>
          </aside>
        </div>
      </main>
    </div>

    <div class="anyai-action-bar" role="region" aria-label="スコアリング操作">
      <button type="button" class="btn btn-soft-accent" data-proxy-for="btn-check-status">CheckSheetInfo</button>
      <button type="button" class="btn btn-soft-accent" data-proxy-for="btn-queue-add-action">Add to Queue</button>
      <button type="button" class="btn btn-primary" data-proxy-for="btn-queue-add-start">Run</button>
    </div>

    <div id="queue-toast" class="queue-toast" role="status" aria-live="polite" aria-hidden="true"></div>

    <script>
      const loadingOverlay = window.AnyAILoading || {
        run: async (task) => task(),
        wrap: (promise) => promise,
        show: () => {},
        hide: () => {},
        requireKeys: async () => true,
      };

      const modeForm = document.getElementById('mode-form');
      const jobForm = document.getElementById('job-form');
      const batchSizeInput = jobForm.querySelector('input[name="batch_size"]');
      const maxCategoryInput = document.getElementById('max_category_cols');
      const concurrencyInput = document.getElementById('concurrency-input');
      const timeoutInput = document.getElementById('timeout-input');
      const sheetKeywordHelp = document.getElementById('sheet-keyword-help');
      const scoreSheetKeywordHelp = document.getElementById('score-sheet-keyword-help');
      const utteranceLabel = document.getElementById('utterance-label');
      const MODE_DEFAULTS = {
        csv: {
          batchSize: '10',
          maxCategoryCols: '200',
          concurrency: '50',
          timeout: '60',
          primaryModel: 'gemini-flash-lite-latest',
          fallbackModel: 'gpt-5-nano',
        },
        video: {
          batchSize: '10',
          maxCategoryCols: '200',
          concurrency: '15',
          timeout: '300',
          primaryModel: 'gemini-flash-latest',
          fallbackModel: '',
        },
      };
      const spreadsheetUrlInput = document.getElementById('spreadsheet_url');
      const setSpreadsheetButton = document.getElementById('btn-spreadsheet-set');
      const sheetKeywordInput = document.getElementById('sheet_keyword');
      const scoreSheetKeywordInput = document.getElementById('score_sheet_keyword');
      const sheetGidInput = document.getElementById('sheet_gid');
      const scoreSheetGidInput = document.getElementById('score_sheet_gid');
      const analysisSheetField = document.getElementById('analysis-sheet-field');
      const scoreSheetField = document.getElementById('score-sheet-field');
      const primaryModelSelect = document.getElementById('primary_model');
      const fallbackModelSelect = document.getElementById('fallback_model');
      const fallbackModelField = document.getElementById('fallback-model-field');
      const modePills = Array.from(document.querySelectorAll('.mode-pill'));
      const modeRadios = modeForm.querySelectorAll('input[name="mode"]');
      const enableSSR = document.getElementById('enable_ssr');
      const enableSSRToggle = enableSSR ? enableSSR.closest('.toggle-switch') : null;
      if (enableSSRToggle) {
        enableSSRToggle.setAttribute('aria-checked', enableSSR.checked ? 'true' : 'false');
      }
      const queueStatus = document.getElementById('queue-status');
      const cancelButton = document.getElementById('btn-cancel-job');
      const resultSection = document.getElementById('result');
      const queueAddButton = document.getElementById('btn-queue-add');
      const queueAddActionButton = document.getElementById('btn-queue-add-action');
      const queueAddStartButton = document.getElementById('btn-queue-add-start');
      const checkStatusButton = document.getElementById('btn-check-status');
      const primaryActionSection = document.getElementById('scoring-action-area');
      const actionBar = document.querySelector('.anyai-action-bar');
      const actionBarButtons = actionBar ? Array.from(actionBar.querySelectorAll('[data-proxy-for]')) : [];
      const primaryPanel = document.querySelector('.anyai-app-primary');
      const validationBanner = document.getElementById('validation-banner');
      const queueToast = document.getElementById('queue-toast');
      let queueToastTimer = null;
      if (queueToast) {
        queueToast.addEventListener('click', () => {
          hideQueueToast();
        });
      }

      const validationStatusCard = document.getElementById('validation-status-card');
      const validationStatusBadge = document.getElementById('validation-status-badge');
      const validationStatusMessage = document.getElementById('validation-status-message');
      const validationStatusMeta = document.getElementById('validation-status-meta');
      const autoSlowdownToggle = document.getElementById('auto_slowdown');
      const systemPromptSSRInput = document.getElementById('system_prompt_ssr');
      const systemPromptNumericInput = document.getElementById('system_prompt_numeric');
      const logCard = document.getElementById('job-log-card');
      const logContent = document.getElementById('job-log-content');
      const logRefreshButton = document.getElementById('btn-log-refresh');
      const defaultLogMessage = 'ジョブを開始するとログが表示されます。';

      const customSelectRegistry = new WeakMap();

      function setupCustomSelect(select) {
        if (!select || customSelectRegistry.has(select)) return;

        const placeholder = select.dataset.placeholder || '';
        const wrapper = document.createElement('div');
        wrapper.className = 'custom-select';

        const toggle = document.createElement('button');
        toggle.type = 'button';
        toggle.className = 'custom-select-toggle';
        toggle.setAttribute('aria-haspopup', 'listbox');
        toggle.setAttribute('aria-expanded', 'false');

        const label = document.createElement('span');
        label.className = 'custom-select-label';
        label.textContent = placeholder;
        toggle.appendChild(label);

        const menu = document.createElement('div');
        menu.className = 'custom-select-menu';
        menu.setAttribute('role', 'listbox');
        menu.hidden = true;
        menu.tabIndex = -1;

        const menuId = `${select.id || `custom-select-${Math.random().toString(36).slice(2)}`}-menu`;
        menu.id = menuId;
        toggle.setAttribute('aria-controls', menuId);
        toggle.setAttribute('role', 'combobox');

        const parent = select.parentNode;
        parent.insertBefore(wrapper, select);
        wrapper.appendChild(toggle);
        wrapper.appendChild(menu);
        wrapper.appendChild(select);

        select.classList.add('custom-select-native');
        select.tabIndex = -1;
        select.setAttribute('aria-hidden', 'true');

        const state = {
          select,
          wrapper,
          toggle,
          label,
          menu,
          placeholder,
          isOpen: false,
          focusIndex: -1,
          optionButtons: [],
          observers: [],
        };

        function refreshLabel() {
          const selected = Array.from(select.selectedOptions || [])[0];
          const text = selected ? selected.textContent : '';
          label.textContent = text || state.placeholder || '';
          state.wrapper.classList.toggle('has-value', Boolean(selected && selected.value));
        }

        function syncSelectedClass() {
          const value = select.value;
          state.optionButtons.forEach((btn) => {
            const isSelected = btn.dataset.value === value;
            btn.classList.toggle('is-selected', isSelected);
            btn.setAttribute('aria-selected', isSelected ? 'true' : 'false');
          });
        }

        function focusOption(index) {
          const enabledOptions = state.optionButtons.filter((btn) => !btn.disabled);
          if (!enabledOptions.length) return;
          const clamped = Math.max(0, Math.min(index, enabledOptions.length - 1));
          const target = enabledOptions[clamped];
          if (!target) return;
          target.focus();
          if (!target.id) {
            const rawIndex = Math.max(0, state.optionButtons.indexOf(target));
            target.id = `${state.menu.id}-option-${rawIndex}`;
          }
          state.toggle.setAttribute('aria-activedescendant', target.id);
          state.focusIndex = clamped;
          const containerRect = state.menu.getBoundingClientRect();
          const targetRect = target.getBoundingClientRect();
          if (targetRect.top < containerRect.top) {
            state.menu.scrollTop -= containerRect.top - targetRect.top + 4;
          } else if (targetRect.bottom > containerRect.bottom) {
            state.menu.scrollTop += targetRect.bottom - containerRect.bottom + 4;
          }
        }

        function focusSelected() {
          const enabledOptions = state.optionButtons.filter((btn) => !btn.disabled);
          const index = enabledOptions.findIndex((btn) => btn.dataset.value === select.value);
          if (index >= 0) {
            focusOption(index);
          } else {
            focusOption(0);
          }
        }

        function closeMenu({ focusToggle = false } = {}) {
          if (!state.isOpen) return;
          state.isOpen = false;
          state.wrapper.classList.remove('is-open');
          state.menu.hidden = true;
          state.toggle.setAttribute('aria-expanded', 'false');
          state.toggle.removeAttribute('aria-activedescendant');
          state.focusIndex = -1;
          document.removeEventListener('pointerdown', handleDocumentPointer, true);
          document.removeEventListener('keydown', handleDocumentKeydown, true);
          if (focusToggle) {
            state.toggle.focus();
          }
        }

        function handleDocumentPointer(event) {
          if (state.wrapper.contains(event.target)) return;
          closeMenu();
        }

        function handleDocumentKeydown(event) {
          if (event.key === 'Escape') {
            event.preventDefault();
            closeMenu({ focusToggle: true });
          }
        }

        function buildMenu() {
          state.menu.innerHTML = '';
          state.menu.scrollTop = 0;
          const options = Array.from(select.options || []);
          state.optionButtons = options.map((option) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'custom-select-option';
          button.textContent = option.textContent;
          button.dataset.value = option.value;
          button.setAttribute('role', 'option');
          button.setAttribute('aria-selected', option.selected ? 'true' : 'false');
          button.tabIndex = -1;
            if (option.disabled) {
              button.disabled = true;
              button.classList.add('is-disabled');
            }
            button.addEventListener('click', () => {
              if (button.disabled) return;
              select.value = option.value;
              select.dispatchEvent(new Event('change', { bubbles: true }));
              closeMenu({ focusToggle: true });
            });
            button.addEventListener('keydown', (event) => {
              if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                button.click();
              } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                focusOption(state.focusIndex + 1);
              } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                focusOption(state.focusIndex - 1);
              } else if (event.key === 'Home') {
                event.preventDefault();
                focusOption(0);
              } else if (event.key === 'End') {
                event.preventDefault();
                const enabled = state.optionButtons.filter((btn) => !btn.disabled);
                focusOption(enabled.length - 1);
              } else if (event.key === 'Escape') {
                event.preventDefault();
                closeMenu({ focusToggle: true });
              }
            });
            state.menu.appendChild(button);
            return button;
          });
          syncSelectedClass();
        }

        function openMenu() {
          if (state.isOpen || select.disabled) return;
          buildMenu();
          state.isOpen = true;
          state.wrapper.classList.add('is-open');
          state.menu.hidden = false;
          state.toggle.setAttribute('aria-expanded', 'true');
          document.addEventListener('pointerdown', handleDocumentPointer, true);
          document.addEventListener('keydown', handleDocumentKeydown, true);
          requestAnimationFrame(() => {
            focusSelected();
          });
        }

        function syncDisabled() {
          const disabled = select.disabled;
          state.toggle.disabled = disabled;
          state.toggle.setAttribute('aria-disabled', disabled ? 'true' : 'false');
          state.wrapper.classList.toggle('is-disabled', disabled);
          if (disabled) {
            closeMenu();
          }
        }

        state.toggle.addEventListener('click', () => {
          if (state.isOpen) {
            closeMenu();
          } else {
            openMenu();
          }
        });

        state.toggle.addEventListener('keydown', (event) => {
          if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
            event.preventDefault();
            openMenu();
          }
        });

        state.menu.addEventListener('focusout', (event) => {
          if (!state.wrapper.contains(event.relatedTarget)) {
            closeMenu();
          }
        });

        select.addEventListener('change', () => {
          refreshLabel();
          syncSelectedClass();
        });

        const optionObserver = new MutationObserver(() => {
          buildMenu();
          refreshLabel();
        });
        optionObserver.observe(select, { childList: true });

        const attributeObserver = new MutationObserver(() => {
          syncDisabled();
        });
        attributeObserver.observe(select, { attributes: true, attributeFilter: ['disabled'] });

        state.observers.push(optionObserver, attributeObserver);

        customSelectRegistry.set(select, {
          state,
          refreshLabel,
          syncDisabled,
          syncSelectedClass,
          setPlaceholder(placeholderText) {
            state.placeholder = placeholderText || '';
            if (!select.value) {
              state.label.textContent = state.placeholder;
            }
          },
        });

        refreshLabel();
        syncDisabled();
        buildMenu();
      }

      function updateCustomSelectPlaceholder(select, placeholderText) {
        const entry = customSelectRegistry.get(select);
        if (!entry) return;
        entry.state.placeholder = placeholderText || '';
        if (!select.value) {
          entry.state.label.textContent = entry.state.placeholder;
        }
        entry.syncSelectedClass();
      }

      function syncCustomSelectDisabled(select) {
        const entry = customSelectRegistry.get(select);
        if (!entry) return;
        entry.syncDisabled();
      }

      function refreshCustomSelect(select) {
        const entry = customSelectRegistry.get(select);
        if (!entry) return;
        entry.refreshLabel();
        entry.syncSelectedClass();
      }

      function isSSREnabled() {
        return Boolean(enableSSR && enableSSR.checked);
      }

      function getSelectValue(select) {
        if (!select) return '';
        const value = select.value ?? '';
        return typeof value === 'string' ? value.trim() : '';
      }

      function getScoreSheetKeyword() {
        return getSelectValue(scoreSheetKeywordInput);
      }

      function getAnalysisSheetKeyword() {
        return isSSREnabled() ? getSelectValue(sheetKeywordInput) : getScoreSheetKeyword();
      }

      function getScoreSheetGid() {
        if (!scoreSheetGidInput) return '';
        const value = scoreSheetGidInput.value ?? '';
        return typeof value === 'string' ? value.trim() : '';
      }

      function getAnalysisSheetGid() {
        if (!sheetGidInput) return '';
        if (isSSREnabled()) {
          const value = sheetGidInput.value ?? '';
          return typeof value === 'string' ? value.trim() : '';
        }
        return getScoreSheetGid();
      }

      function syncAnalysisSheetSelection() {
        if (!sheetKeywordInput) return;
        const ssrEnabled = isSSREnabled();
        const hasSheetOptions = Boolean(
          sheetKeywordInput && sheetKeywordInput.options && sheetKeywordInput.options.length > 1
        );
        const scoreValue = getScoreSheetKeyword();
        const scorePlaceholder =
          (scoreSheetKeywordInput && scoreSheetKeywordInput.dataset.placeholder) || 'Setで読み込んでください';

        if (ssrEnabled && hasSheetOptions) {
          sheetKeywordInput.disabled = false;
          const previousPlaceholder = sheetKeywordInput.dataset.previousPlaceholder;
          if (previousPlaceholder !== undefined) {
            sheetKeywordInput.dataset.placeholder = previousPlaceholder || sheetKeywordInput.dataset.placeholder || '';
            updateCustomSelectPlaceholder(sheetKeywordInput, sheetKeywordInput.dataset.placeholder || '');
            delete sheetKeywordInput.dataset.previousPlaceholder;
          }
        } else {
          if (!hasSheetOptions) {
            delete sheetKeywordInput.dataset.previousPlaceholder;
          } else if (sheetKeywordInput.dataset.previousPlaceholder === undefined) {
            sheetKeywordInput.dataset.previousPlaceholder = sheetKeywordInput.dataset.placeholder || '';
          }

          if (scoreValue) {
            const options = Array.from(sheetKeywordInput.options || []);
            const match = options.find((option) => option.value === scoreValue);
            if (match) {
              sheetKeywordInput.value = match.value;
            } else {
              sheetKeywordInput.value = '';
            }
          } else {
            sheetKeywordInput.value = '';
          }

          sheetKeywordInput.disabled = true;
          const linkedPlaceholder = ssrEnabled && !hasSheetOptions
            ? 'Setで読み込んでください'
            : scoreValue
              ? 'スコアシートと同じ'
              : scorePlaceholder;
          sheetKeywordInput.dataset.placeholder = linkedPlaceholder;
          updateCustomSelectPlaceholder(sheetKeywordInput, linkedPlaceholder);
          if (sheetGidInput) {
            sheetGidInput.value = scoreValue ? getScoreSheetGid() : '';
          }
        }

        syncCustomSelectDisabled(sheetKeywordInput);
        refreshCustomSelect(sheetKeywordInput);
        updateSheetSelectionInputs();
      }

      function positionActionBar() {
        if (!actionBar || !primaryPanel) return;
        const hasVisibleProxy = actionBarButtons.some((proxy) => proxy.style.display !== 'none');
        if (!hasVisibleProxy) return;
        const panelRect = primaryPanel.getBoundingClientRect();
        if (panelRect.width <= 0) return;
        actionBar.style.removeProperty('width');
        const naturalWidth = actionBar.offsetWidth;
        const maxWidth = Math.max(panelRect.width - 24, 0);
        const finalWidth = maxWidth > 0 ? Math.min(naturalWidth, maxWidth) : naturalWidth;
        actionBar.style.width = `${finalWidth}px`;
        actionBar.style.left = `${panelRect.left + panelRect.width / 2}px`;
      }

      if (actionBar && actionBarButtons.length) {
        actionBarButtons.forEach((proxy) => {
          const targetId = proxy.dataset.proxyFor;
          proxy.addEventListener('click', (event) => {
            if (!targetId) return;
            const target = document.getElementById(targetId);
            if (!target || target.disabled) {
              event.preventDefault();
              return;
            }
            target.click();
          });
        });
      }

      if (primaryActionSection && actionBar) {
        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              positionActionBar();
              if (entry.isIntersecting) {
                actionBar.classList.add('is-hidden');
              } else {
                actionBar.classList.remove('is-hidden');
              }
            });
          },
          { threshold: 0.2 },
        );
        observer.observe(primaryActionSection);
      }

      if (actionBar) {
        positionActionBar();
        window.addEventListener('resize', positionActionBar);
        window.addEventListener('orientationchange', positionActionBar);
        if (primaryPanel && 'ResizeObserver' in window) {
          const actionBarResizeObserver = new ResizeObserver(() => positionActionBar());
          actionBarResizeObserver.observe(primaryPanel);
        }
      }

      const validation = (() => {
        const state = { ok: false, payload: null, cacheKey: '', message: '', status: 'info' };

        function buildKey() {
          const url = resolvedSpreadsheetId || spreadsheetUrlInput.value.trim();
          const sheetKeyword = getAnalysisSheetKeyword();
          const scoreKeyword = getScoreSheetKeyword();
          const sheetGid = getAnalysisSheetGid();
          const scoreGid = getScoreSheetGid();
          return [url, sheetGid || sheetKeyword, scoreGid || scoreKeyword].join('|');
        }

        function updateCard(status = 'info', message = '', payload = null) {
          if (!validationStatusCard) return;
          const normalizedStatus = status || 'info';
          const hasMeta =
            payload && typeof payload === 'object' && payload !== null && Object.keys(payload).length > 0;
          const hasMessage = Boolean(message);

          if (!hasMessage && !hasMeta && normalizedStatus === 'idle') {
            validationStatusCard.style.display = 'none';
            return;
          }

          validationStatusCard.style.display = '';
          if (validationStatusBadge) {
            const labelMap = { success: '検証済み', error: '要対応', info: '待機中', idle: '待機中' };
            validationStatusBadge.textContent = labelMap[normalizedStatus] || '待機中';
            const badgeState = normalizedStatus === 'idle' ? 'info' : normalizedStatus;
            validationStatusBadge.setAttribute('data-state', badgeState);
          }

          if (validationStatusMessage) {
            validationStatusMessage.textContent = message || 'Setボタンでシートを読み込み、項目を選択して検証を完了してください。';
          }

          if (validationStatusMeta) {
            validationStatusMeta.replaceChildren();
            if (hasMeta) {
              const entries = [];
              if (payload.sheet_name) entries.push(['Sheet Name', String(payload.sheet_name)]);
              if (payload.sheet_id !== undefined && payload.sheet_id !== null) {
                entries.push(['Sheet ID', String(payload.sheet_id)]);
              }
              if (payload.spreadsheet_id) {
                entries.push(['Spreadsheet ID', String(payload.spreadsheet_id)]);
              }
              if (
                payload.score_sheet_name &&
                payload.score_sheet_name !== payload.sheet_name
              ) {
                entries.push(['Score Sheet', String(payload.score_sheet_name)]);
              }
              if (
                payload.score_sheet_id !== undefined &&
                payload.score_sheet_id !== null &&
                payload.score_sheet_id !== payload.sheet_id
              ) {
                entries.push(['Score Sheet ID', String(payload.score_sheet_id)]);
              }

              if (entries.length) {
                entries.forEach(([label, value]) => {
                  const row = document.createElement('div');
                  row.className = 'validation-meta-row';
                  const labelEl = document.createElement('span');
                  labelEl.className = 'validation-meta-label';
                  labelEl.textContent = label;
                  const valueEl = document.createElement('code');
                  valueEl.textContent = value;
                  row.appendChild(labelEl);
                  row.appendChild(valueEl);
                  validationStatusMeta.appendChild(row);
                });
                validationStatusMeta.style.display = '';
              } else {
                validationStatusMeta.style.display = 'none';
              }
            } else {
              validationStatusMeta.style.display = 'none';
            }
          }
        }

        function setResult(ok, payload, message, status) {
          state.ok = Boolean(ok);
          state.payload = payload ?? null;
          state.message = message ?? '';
          state.status = status || (state.ok ? 'success' : 'error');
          state.cacheKey = state.ok ? buildKey() : '';
          updateCard(state.status, state.message, state.payload);
        }

        function markDirty(showMessage = true) {
          const wasValid = state.ok;
          state.ok = false;
          state.payload = null;
          state.cacheKey = '';
          state.status = 'info';
          state.message = '';
          const infoMessage = wasValid
            ? '設定が変更されました。シート検証を完了してください。'
            : 'Setボタンでシートを読み込み、項目を選択してください。';
          updateCard('info', infoMessage, null);
          if (showMessage && wasValid) {
            showValidationBanner('info', '設定が変更されました。再度シート検証を実行してください。');
          } else if (!validationBanner?.hasAttribute('data-state')) {
            showValidationBanner(null, '');
          }
        }

        function isCurrent() {
          return state.ok && state.cacheKey === buildKey();
        }

        return { state, buildKey, updateCard, setResult, markDirty, isCurrent };
      })();

      function resetLogView() {
        if (!logCard || !logContent) return;
        logContent.textContent = defaultLogMessage;
      }

      async function refreshJobLog(jobId, { manual = false } = {}) {
        if (!logCard || !logContent) return;
        if (!jobId) {
          resetLogView();
          return;
        }
        try {
          const res = await fetch(`/jobs/${jobId}/log?lines=400`);
          if (!res.ok) {
            if (res.status === 404) {
              logContent.textContent = 'ログはまだ生成されていません。';
              return;
            }
            throw new Error(`status ${res.status}`);
          }
          const data = await res.json();
          const logText = data.log || '';
          logContent.textContent = logText || 'ログはまだ記録されていません。';
          logContent.scrollTop = logContent.scrollHeight;
        } catch (err) {
          if (manual) {
            showQueueToast('ログの取得に失敗しました。', { state: 'error' });
          } else {
            console.warn('Failed to load job log', err);
          }
        }
      }
      let currentMode = modeForm.querySelector('input[name="mode"]:checked').value;
      let currentJobId = null;
      let pollTimer = null;
      let resolvedSpreadsheetId = '';
      let resolvedSheets = [];
      let autoCheckTimer = null;

      if (logRefreshButton) {
        logRefreshButton.addEventListener('click', () => {
          if (currentJobId) {
            refreshJobLog(currentJobId, { manual: true });
          } else {
            resetLogView();
          }
        });
      }

      const nonSSRState = {
        csv: { ...MODE_DEFAULTS.csv },
        video: { ...MODE_DEFAULTS.video }
      };
      nonSSRState.csv = {
        batchSize: batchSizeInput.value || MODE_DEFAULTS.csv.batchSize,
        maxCategoryCols: (maxCategoryInput && maxCategoryInput.value) || MODE_DEFAULTS.csv.maxCategoryCols,
        concurrency: concurrencyInput.value || MODE_DEFAULTS.csv.concurrency,
        timeout: timeoutInput.value || MODE_DEFAULTS.csv.timeout
      };
      const modeModelState = {
        csv: {
          primary: (primaryModelSelect && primaryModelSelect.value) || MODE_DEFAULTS.csv.primaryModel,
          fallback: (fallbackModelSelect && fallbackModelSelect.value) || MODE_DEFAULTS.csv.fallbackModel,
        },
        video: {
          primary: MODE_DEFAULTS.video.primaryModel,
          fallback: MODE_DEFAULTS.video.fallbackModel,
        },
      };

      function syncActionProxies() {
        if (!actionBarButtons.length) return;
        actionBarButtons.forEach((proxy) => {
          const targetId = proxy.dataset.proxyFor;
          const target = targetId ? document.getElementById(targetId) : null;
          if (!target) {
            proxy.disabled = true;
            proxy.style.display = 'none';
            return;
          }
          const targetStyle = window.getComputedStyle(target);
          const hidden =
            targetStyle.display === 'none' ||
            targetStyle.visibility === 'hidden' ||
            target.hasAttribute('hidden');
          proxy.style.display = hidden ? 'none' : '';
          proxy.disabled = target.disabled;
          proxy.textContent = target.textContent;
          if (target.hasAttribute('aria-busy')) {
            proxy.setAttribute('aria-busy', target.getAttribute('aria-busy') || 'false');
          } else {
            proxy.removeAttribute('aria-busy');
          }
        });
        if (actionBar) {
          const anyVisible = actionBarButtons.some((proxy) => proxy.style.display !== 'none');
          actionBar.classList.toggle('is-empty', !anyVisible);
          positionActionBar();
        }
      }

      function setValidationResult(ok, payload, message, status){
        validation.setResult(ok, payload, message, status);
        updateQueueActionState();
      }

      function isValidationCurrent(){
        return validation.isCurrent();
      }

      function showValidationBanner(state, message){
        if(!validationBanner) return;
        if(!state){
          validationBanner.removeAttribute('data-state');
          validationBanner.textContent = message || '';
          return;
        }
        validationBanner.setAttribute('data-state', state);
        validationBanner.textContent = message || '';
      }

      function hideQueueToast(){
        if (!queueToast) return;
        if (queueToastTimer) {
          clearTimeout(queueToastTimer);
          queueToastTimer = null;
        }
        queueToast.classList.remove('is-visible');
        queueToast.setAttribute('aria-hidden', 'true');
        window.setTimeout(() => {
          if (!queueToast.classList.contains('is-visible')) {
            queueToast.textContent = '';
            queueToast.removeAttribute('data-state');
          }
        }, 220);
      }

      function showQueueToast(message, options = {}){
        if (!queueToast) return;
        const state = options.state || 'success';
        const duration =
          typeof options.duration === 'number' ? options.duration : 3000;
        if (queueToastTimer) {
          clearTimeout(queueToastTimer);
          queueToastTimer = null;
        }
        queueToast.setAttribute('data-state', state);
        queueToast.textContent = message || '';
        queueToast.setAttribute('aria-hidden', 'false');
        void queueToast.offsetWidth;
        queueToast.classList.add('is-visible');
        if (duration > 0) {
          queueToastTimer = window.setTimeout(() => {
            hideQueueToast();
          }, duration);
        }
      }

      function updateQueueActionState(){
        const valid = isValidationCurrent();
        if(queueAddButton) queueAddButton.disabled = !valid;
        if (queueAddActionButton) {
          queueAddActionButton.disabled = !valid;
          queueAddActionButton.style.display = valid ? '' : 'none';
        }
        if(queueAddStartButton){
          queueAddStartButton.disabled = !valid;
          queueAddStartButton.style.display = valid ? '' : 'none';
        }
        if(checkStatusButton){
          checkStatusButton.style.display = valid ? 'none' : '';
          if (!valid) {
            checkStatusButton.disabled = false;
          }
        }
        syncActionProxies();
      }

      function lockActionButtons(lock) {
        [queueAddButton, queueAddActionButton, checkStatusButton].forEach((btn) => {
          if (!btn) return;
          if (lock) {
            btn.dataset.prevDisabled = btn.disabled ? 'true' : 'false';
            btn.disabled = true;
          } else {
            const wasDisabled = btn.dataset.prevDisabled === 'true';
            delete btn.dataset.prevDisabled;
            btn.disabled = wasDisabled;
          }
        });
        if (!lock) {
          updateQueueActionState();
        } else {
          syncActionProxies();
        }
      }

      function setButtonBusy(button, busyLabel){
        if(!button) return () => {};
        const originalWidth = button.offsetWidth || button.getBoundingClientRect().width;
        const original = {
          text: button.textContent,
          width: originalWidth,
          minWidth: button.style.minWidth,
          disabled: button.disabled,
        };
        button.setAttribute('aria-busy', 'true');
        button.disabled = true;
        if (busyLabel) {
          button.textContent = busyLabel;
        }
        if (original.width) {
          const busyWidth = Math.max(original.width, button.offsetWidth || button.getBoundingClientRect().width);
          button.style.minWidth = `${busyWidth}px`;
        }
        syncActionProxies();
        return () => {
          button.removeAttribute('aria-busy');
          button.style.removeProperty('min-width');
          if (busyLabel) {
            button.textContent = original.text;
          }
          button.disabled = original.disabled;
          if (original.minWidth) {
            button.style.minWidth = original.minWidth;
          }
          syncActionProxies();
        };
      }

      async function runWithOverlay(task){
        try {
          await loadingOverlay.requireKeys();
          loadingOverlay.show();
        } catch (err) {
          console.warn('Failed to show loading overlay', err);
        }
        try {
          return await task();
        } finally {
          try {
            loadingOverlay.hide();
          } catch (err) {
            console.warn('Failed to hide loading overlay', err);
          }
        }
      }

      async function ensureQueueRunning() {
        try {
          const res = await fetch('/queue/start', { method: 'POST' });
          if (!res.ok) {
            console.warn('Queue runner start request failed', res.status);
          }
        } catch (err) {
          console.warn('Unable to trigger queue runner', err);
        }
      }

      function markValidationDirty(showMessage = true){
        validation.markDirty(showMessage);
        updateQueueActionState();
      }

      function stopPolling(){
        if (pollTimer) {
          clearTimeout(pollTimer);
          pollTimer = null;
        }
      }

      async function fetchProgress(jobId){
        const res = await fetch(`/jobs/${jobId}`);
        if (!res.ok) throw new Error('progress fetch failed');
        return res.json();
      }

      async function updateProgress(jobId){
        try {
          const data = await fetchProgress(jobId);
          document.getElementById('prog').value = data.total_rows ? Math.floor((data.processed_rows / data.total_rows) * 100) : 0;
          document.getElementById('stat').textContent = data.status;
          document.getElementById('eta').textContent = data.eta_seconds ? `予測残り ${Math.round(data.eta_seconds)} 秒` : '';
          const isRunning = data.status === 'running' || data.status === 'pending';
          cancelButton.style.display = isRunning ? 'inline-flex' : 'none';
          return isRunning;
        } catch (err) {
          console.error(err);
          cancelButton.style.display = 'none';
          return false;
        }
      }

      async function startPolling(jobId){
        stopPolling();
        if (!jobId) {
          document.getElementById('prog').value = 0;
          document.getElementById('stat').textContent = '';
          document.getElementById('eta').textContent = '';
          resetLogView();
          return;
        }
        const keepRunning = await updateProgress(jobId);
        await refreshJobLog(jobId);
        if (keepRunning) {
          pollTimer = setTimeout(()=>startPolling(jobId), 2000);
        }
      }

      function storeCurrentNonSSRValues(mode) {
        if (!mode || !nonSSRState[mode]) return;
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        nonSSRState[mode] = {
          batchSize: batchSizeInput.value || defaults.batchSize,
          maxCategoryCols: (maxCategoryInput && maxCategoryInput.value) || defaults.maxCategoryCols,
          concurrency: concurrencyInput.value || defaults.concurrency,
          timeout: timeoutInput.value || defaults.timeout
        };
      }

      function restoreNonSSRValues(mode) {
        if (!mode) return;
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        const stored = nonSSRState[mode] || defaults;
        batchSizeInput.value = stored.batchSize || defaults.batchSize;
        if (maxCategoryInput) {
          maxCategoryInput.value = stored.maxCategoryCols || defaults.maxCategoryCols;
        }
        concurrencyInput.value = stored.concurrency || defaults.concurrency;
        timeoutInput.value = stored.timeout || defaults.timeout;
      }

      function storeModeModels(mode) {
        if (!mode || !modeModelState[mode]) return;
        if (primaryModelSelect) {
          modeModelState[mode].primary = primaryModelSelect.value || '';
        }
        if (fallbackModelSelect && !fallbackModelSelect.disabled) {
          modeModelState[mode].fallback = fallbackModelSelect.value || '';
        }
        if (mode === 'video') {
          modeModelState.video.fallback = '';
        }
      }

      function clearSheetSelections(message = 'Setで読み込んでください') {
        if (sheetKeywordInput) {
          sheetKeywordInput.innerHTML = '';
          const option = document.createElement('option');
          option.value = '';
          option.textContent = message;
          sheetKeywordInput.appendChild(option);
          sheetKeywordInput.value = '';
          sheetKeywordInput.disabled = true;
          sheetKeywordInput.dataset.placeholder = message;
          updateCustomSelectPlaceholder(sheetKeywordInput, message);
          syncCustomSelectDisabled(sheetKeywordInput);
          refreshCustomSelect(sheetKeywordInput);
        }
        if (scoreSheetKeywordInput) {
          scoreSheetKeywordInput.innerHTML = '';
          const option = document.createElement('option');
          option.value = '';
          option.textContent = message;
          scoreSheetKeywordInput.appendChild(option);
          scoreSheetKeywordInput.value = '';
          scoreSheetKeywordInput.disabled = true;
          scoreSheetKeywordInput.dataset.placeholder = message;
          updateCustomSelectPlaceholder(scoreSheetKeywordInput, message);
          syncCustomSelectDisabled(scoreSheetKeywordInput);
          refreshCustomSelect(scoreSheetKeywordInput);
        }
        if (sheetGidInput) sheetGidInput.value = '';
        if (scoreSheetGidInput) scoreSheetGidInput.value = '';
      }

      function updateSheetSelectionInputs() {
        if (sheetKeywordInput && sheetGidInput) {
          const selected = sheetKeywordInput.selectedOptions && sheetKeywordInput.selectedOptions[0];
          sheetGidInput.value = selected && selected.value ? (selected.dataset.sheetId || '') : '';
        }
        if (scoreSheetKeywordInput && scoreSheetGidInput) {
          const selected = scoreSheetKeywordInput.selectedOptions && scoreSheetKeywordInput.selectedOptions[0];
          scoreSheetGidInput.value = selected && selected.value ? (selected.dataset.sheetId || '') : '';
        }
      }

      function populateSheetOptions(sheets, opts = {}) {
        resolvedSheets = Array.isArray(sheets) ? sheets : [];
        const hasSheets = resolvedSheets.length > 0;
        const placeholderLabel = hasSheets ? '対象シートを選択してください' : 'シートが見つかりません';
        const {
          analysisGid = sheetGidInput?.value,
          scoreGid = scoreSheetGidInput?.value,
          analysisName = sheetKeywordInput?.value,
          scoreName = scoreSheetKeywordInput?.value,
        } = opts;
        const analysisNameLower = (analysisName || '').toLowerCase();
        const scoreNameLower = (scoreName || '').toLowerCase();

        const buildOptions = (selectEl, targetGid) => {
          if (!selectEl) return;
          selectEl.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = placeholderLabel;
          selectEl.appendChild(placeholder);
          selectEl.dataset.placeholder = placeholderLabel;
          const targetNameLower = selectEl === sheetKeywordInput ? analysisNameLower : scoreNameLower;
          resolvedSheets.forEach((item) => {
            const option = document.createElement('option');
            option.value = item.sheet_name;
            option.textContent = item.sheet_name;
            option.dataset.sheetId = String(item.sheet_id);
            const matchesGid = targetGid && Number(targetGid) === Number(item.sheet_id);
            const matchesName = !targetGid && targetNameLower && targetNameLower === item.sheet_name.toLowerCase();
            if (matchesGid || matchesName) {
              option.selected = true;
            }
            selectEl.appendChild(option);
          });
          selectEl.disabled = !hasSheets;
          if (!selectEl.disabled && !selectEl.value && selectEl.options.length > 1) {
            selectEl.value = '';
          }
          updateCustomSelectPlaceholder(selectEl, placeholderLabel);
          syncCustomSelectDisabled(selectEl);
          refreshCustomSelect(selectEl);
        };

        buildOptions(sheetKeywordInput, analysisGid);
        buildOptions(scoreSheetKeywordInput, scoreGid);
        updateSheetSelectionInputs();
        syncAnalysisSheetSelection();
      }

      async function handleSpreadsheetSet() {
        if (!spreadsheetUrlInput || !setSpreadsheetButton) return;
        const url = spreadsheetUrlInput.value.trim();
        if (!url) {
          const message = 'スプレッドシートURLを入力してください。';
          showValidationBanner('error', message);
          setValidationResult(false, null, message, 'error');
          return;
        }
        resolvedSpreadsheetId = '';
        resolvedSheets = [];
        clearSheetSelections('シート一覧を取得中...');
        markValidationDirty(false);
        const release = setButtonBusy(setSpreadsheetButton, '取得中...');
        try {
          const res = await fetch('/sheets/list', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ spreadsheet_url: url }),
          });
          let data = null;
          try {
            data = await res.json();
          } catch (err) {
            data = null;
          }
          if (!res.ok || !data || !data.ok) {
            const message = (data && data.message) || 'シート一覧の取得に失敗しました。';
            showValidationBanner('error', message);
            setValidationResult(false, null, message, 'error');
            clearSheetSelections('再度 Set を実行してください');
            return;
          }
          resolvedSpreadsheetId = data.spreadsheet_id || url;
          populateSheetOptions(Array.isArray(data.sheets) ? data.sheets : []);
          const message = 'シート一覧を読み込みました。分析/スコアシートを選択してください。';
          showValidationBanner('info', message);
          setValidationResult(false, null, message, 'info');
        } catch (err) {
          const message = `シート一覧の取得に失敗しました: ${err instanceof Error ? err.message : err}`;
          showValidationBanner('error', message);
          setValidationResult(false, null, message, 'error');
          clearSheetSelections('再度 Set を実行してください');
        } finally {
          release();
        }
      }

      function attemptAutoCheck() {
        if (!resolvedSpreadsheetId) return;
        const sheetValue = getAnalysisSheetKeyword();
        const scoreValue = getScoreSheetKeyword();
        if (!sheetValue || !scoreValue) {
          return;
        }
        if (autoCheckTimer) {
          clearTimeout(autoCheckTimer);
        }
        autoCheckTimer = setTimeout(() => {
          autoCheckTimer = null;
          void performSheetCheck({ auto: true });
        }, 200);
      }

      function toggleSheetFields(ssrEnabled) {
        if (analysisSheetField) {
          analysisSheetField.style.display = ssrEnabled ? '' : 'none';
        }
        if (scoreSheetField) {
          scoreSheetField.style.display = '';
        }
      }

      setupCustomSelect(sheetKeywordInput);
      setupCustomSelect(scoreSheetKeywordInput);
      setupCustomSelect(primaryModelSelect);
      setupCustomSelect(fallbackModelSelect);

      clearSheetSelections();

      const unlockInput = (el, min, max) => {
        if (!el) return;
        el.removeAttribute('readonly');
        el.removeAttribute('aria-readonly');
        el.min = min;
        el.max = max;
      };

      function applyModeContent(mode) {
        if (mode === 'video') {
          sheetKeywordHelp.textContent = 'Videoモードでは動画リンク列を指定してください。Google Drive共有リンクを想定。';
          if (scoreSheetKeywordHelp) {
            scoreSheetKeywordHelp.textContent = '動画モードで数値化したスコアを書き込むシート名に含まれるキーワード。';
          }
          utteranceLabel.textContent = '動画リンク列番号';
        } else {
          sheetKeywordHelp.textContent = '自然言語の分析結果を書き込むシート名に含まれるキーワード。該当シートが1つのみである必要があります。';
          if (scoreSheetKeywordHelp) {
            scoreSheetKeywordHelp.textContent = '分析テキストと同じ位置にスコアを書き込むシート名に含まれるキーワード。';
          }
          utteranceLabel.textContent = '発話列番号';
        }
      }

      function updateSSREnabled() {
        const enabled = enableSSR.checked;
        document.querySelectorAll('[data-ssr-mode]').forEach((el) => {
          const mode = el.getAttribute('data-ssr-mode');
          const show = mode === 'on' ? enabled : !enabled;
          el.style.display = show ? '' : 'none';
        });
      }

      function applyMode(mode) {
        applyModeContent(mode);
        if (!modeModelState[mode]) {
          modeModelState[mode] = { primary: '', fallback: '' };
        }
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        const isVideoMode = mode === 'video';
        const ssrEnabled = enableSSR.checked;

        if (primaryModelSelect) {
          let desiredPrimary = modeModelState[mode].primary || defaults.primaryModel || '';
          if (isVideoMode && defaults.primaryModel) {
            desiredPrimary = defaults.primaryModel;
          }
          if (desiredPrimary && primaryModelSelect.querySelector(`option[value="${desiredPrimary}"]`)) {
            primaryModelSelect.value = desiredPrimary;
          } else if (defaults.primaryModel && primaryModelSelect.querySelector(`option[value="${defaults.primaryModel}"]`)) {
            primaryModelSelect.value = defaults.primaryModel;
            modeModelState[mode].primary = defaults.primaryModel;
          }
          refreshCustomSelect(primaryModelSelect);
        }

        if (fallbackModelField && fallbackModelSelect) {
          if (isVideoMode) {
            fallbackModelField.style.display = 'none';
            fallbackModelSelect.disabled = true;
            fallbackModelSelect.value = '';
            modeModelState[mode].fallback = '';
            syncCustomSelectDisabled(fallbackModelSelect);
            refreshCustomSelect(fallbackModelSelect);
          } else {
            fallbackModelField.style.display = '';
            fallbackModelSelect.disabled = false;
            let desiredFallback = modeModelState[mode].fallback || defaults.fallbackModel || '';
            if (desiredFallback && fallbackModelSelect.querySelector(`option[value="${desiredFallback}"]`)) {
              fallbackModelSelect.value = desiredFallback;
            } else if (defaults.fallbackModel && fallbackModelSelect.querySelector(`option[value="${defaults.fallbackModel}"]`)) {
              fallbackModelSelect.value = defaults.fallbackModel;
              modeModelState[mode].fallback = defaults.fallbackModel;
            } else {
              fallbackModelSelect.value = '';
              modeModelState[mode].fallback = '';
            }
            syncCustomSelectDisabled(fallbackModelSelect);
            refreshCustomSelect(fallbackModelSelect);
          }
        }

        const storedValues = nonSSRState[mode] || defaults;

        restoreNonSSRValues(mode);

        unlockInput(batchSizeInput, '1', '50');
        if (!batchSizeInput.value) {
          batchSizeInput.value = storedValues.batchSize || defaults.batchSize;
        }

        if (maxCategoryInput) {
          unlockInput(maxCategoryInput, '1', '10000');
          if (!maxCategoryInput.value) {
            maxCategoryInput.value = storedValues.maxCategoryCols || defaults.maxCategoryCols;
          }
        }

        if (!concurrencyInput.value || isVideoMode) {
          concurrencyInput.value = defaults.concurrency || MODE_DEFAULTS.csv.concurrency;
        }
        if (!timeoutInput.value || isVideoMode) {
          timeoutInput.value = defaults.timeout || MODE_DEFAULTS.csv.timeout;
        }

        batchSizeInput.removeAttribute('title');
        batchSizeInput.removeAttribute('aria-disabled');
        batchSizeInput.disabled = false;

        updateSSREnabled();
        toggleSheetFields(ssrEnabled);
        syncAnalysisSheetSelection();

        if (primaryModelSelect) {
          modeModelState[mode].primary = primaryModelSelect.value || '';
        }
        if (fallbackModelSelect && !fallbackModelSelect.disabled) {
          modeModelState[mode].fallback = fallbackModelSelect.value || '';
        }
      }

      function handleSSRChange() {
        const enabled = enableSSR.checked;
        if (enabled) {
          storeCurrentNonSSRValues(currentMode);
        }
        applyMode(currentMode);
      }

      function appendPromptFields(fd) {
        const ssrPrompt = systemPromptSSRInput ? systemPromptSSRInput.value : '';
        const numericPrompt = systemPromptNumericInput ? systemPromptNumericInput.value : '';
        fd.set('enable_ssr', enableSSR.checked ? 'true' : 'false');
        fd.set('system_prompt_ssr', ssrPrompt);
        fd.set('system_prompt_numeric', numericPrompt);
        const activePrompt = enableSSR.checked ? ssrPrompt : numericPrompt;
        fd.set('system_prompt', activePrompt || '');
      }

      async function performSheetCheck(options = {}) {
        const { auto = false } = options;
        if (!spreadsheetUrlInput) return;
        const url = spreadsheetUrlInput.value.trim();
        const sheetKeyword = getAnalysisSheetKeyword();
        const scoreSheetKeyword = getScoreSheetKeyword();
        if (!url || !sheetKeyword || !scoreSheetKeyword) {
          return;
        }

        const payload = {
          spreadsheet_url: url,
          sheet_keyword: sheetKeyword,
          score_sheet_keyword: scoreSheetKeyword,
        };
        const sheetGid = getAnalysisSheetGid();
        const scoreGid = getScoreSheetGid();
        const parsedSheetGid = sheetGid ? Number(sheetGid) : NaN;
        const parsedScoreGid = scoreGid ? Number(scoreGid) : NaN;
        if (!Number.isNaN(parsedSheetGid)) payload.sheet_gid = parsedSheetGid;
        if (!Number.isNaN(parsedScoreGid)) payload.score_sheet_gid = parsedScoreGid;

        showValidationBanner('info', auto ? 'シートを検証中です...' : 'スプレッドシートを検証中です...');
        if (!auto && checkStatusButton) {
          checkStatusButton.disabled = true;
        }

        try {
          const res = await fetch('/jobs/check', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          let data = null;
          try {
            data = await res.json();
          } catch (err) {
            data = null;
          }
          if (!res.ok || !data || !data.ok) {
            const message = (data && data.message) || 'スプレッドシートの検証に失敗しました。';
            showValidationBanner('error', message);
            setValidationResult(false, data, message, 'error');
          } else {
            const message = data.message || 'スプレッドシートを確認しました。';
            resolvedSpreadsheetId = data.spreadsheet_id || resolvedSpreadsheetId || url;
            showValidationBanner('success', message);
            setValidationResult(true, data, message, 'success');
          }
        } catch (err) {
          const message = `検証に失敗しました: ${err instanceof Error ? err.message : err}`;
          showValidationBanner('error', message);
          setValidationResult(false, null, message, 'error');
        } finally {
          if (checkStatusButton) {
            checkStatusButton.disabled = false;
          }
        }
      }

      function buildJobFormData(action) {
        const fd = new FormData(form);
        if (autoSlowdownToggle) {
          fd.set('auto_slowdown', autoSlowdownToggle.checked ? 'true' : 'false');
        }
        const selectedMode = modeForm.querySelector('input[name="mode"]:checked').value;
        fd.set('mode', selectedMode);
        if (enableSSR.checked) {
          fd.set('batch_size', '1');
        }
        fd.set('sheet_keyword', getAnalysisSheetKeyword());
        fd.set('score_sheet_keyword', getScoreSheetKeyword());
        const sheetGid = getAnalysisSheetGid();
        const scoreGid = getScoreSheetGid();
        if (sheetGid) {
          fd.set('sheet_gid', sheetGid);
        } else {
          fd.delete('sheet_gid');
        }
        if (scoreGid) {
          fd.set('score_sheet_gid', scoreGid);
        } else {
          fd.delete('score_sheet_gid');
        }
        appendPromptFields(fd);
        if (primaryModelSelect) {
          fd.set('primary_model', primaryModelSelect.value || '');
        }
        if (fallbackModelSelect) {
          const fallbackValue = fallbackModelSelect.disabled ? '' : (fallbackModelSelect.value || '');
          fd.set('fallback_model', fallbackValue);
        }
        if (action) {
          fd.set('action', action);
        }
        return fd;
      }

      enableSSR.addEventListener('change', () => {
        if (enableSSRToggle) {
          enableSSRToggle.setAttribute('aria-checked', enableSSR.checked ? 'true' : 'false');
        }
        handleSSRChange();
      });

      if (enableSSRToggle) {
        enableSSRToggle.addEventListener('click', (event) => {
          if (event.target === enableSSR) return;
          event.preventDefault();
          enableSSR.checked = !enableSSR.checked;
          enableSSRToggle.setAttribute('aria-checked', enableSSR.checked ? 'true' : 'false');
          handleSSRChange();
        });
        enableSSRToggle.addEventListener('keydown', (event) => {
          if (event.key === ' ' || event.key === 'Enter') {
            event.preventDefault();
            enableSSR.checked = !enableSSR.checked;
            enableSSRToggle.setAttribute('aria-checked', enableSSR.checked ? 'true' : 'false');
            handleSSRChange();
          }
        });
      }

      function setModeSelection(newMode) {
        modeRadios.forEach((radio) => {
          radio.checked = radio.value === newMode;
        });
        modePills.forEach((pill) => {
          const isActive = pill.dataset.mode === newMode;
          pill.setAttribute('aria-checked', isActive ? 'true' : 'false');
          pill.tabIndex = isActive ? 0 : -1;
        });
      }

      function handleModeChange(newMode) {
        if (newMode === currentMode) return;
        if (!enableSSR.checked) {
          storeCurrentNonSSRValues(currentMode);
        }
        storeModeModels(currentMode);
        currentMode = newMode;
        applyMode(currentMode);
        setModeSelection(currentMode);
      }

      modePills.forEach((pill) => {
        pill.addEventListener('click', (event) => {
          event.preventDefault();
          const newMode = pill.dataset.mode;
          handleModeChange(newMode);
        });
        pill.addEventListener('keydown', (event) => {
          const modes = modePills.map((p) => p.dataset.mode);
          const currentIndex = modes.indexOf(currentMode);
          if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
            event.preventDefault();
            const nextIndex = (currentIndex + 1) % modes.length;
            handleModeChange(modes[nextIndex]);
            modePills[nextIndex].focus();
          } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
            event.preventDefault();
            const prevIndex = (currentIndex - 1 + modes.length) % modes.length;
            handleModeChange(modes[prevIndex]);
            modePills[prevIndex].focus();
          } else if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            handleModeChange(pill.dataset.mode);
          }
        });
      });

      modeRadios.forEach((radio) => {
        radio.addEventListener('change', () => {
          if (!radio.checked) return;
          handleModeChange(radio.value);
        });
      });

      setModeSelection(currentMode);

      if (primaryModelSelect) {
        primaryModelSelect.addEventListener('change', () => {
          if (!modeModelState[currentMode]) {
            modeModelState[currentMode] = { primary: '', fallback: '' };
          }
          modeModelState[currentMode].primary = primaryModelSelect.value || '';
        });
      }

      if (fallbackModelSelect) {
        fallbackModelSelect.addEventListener('change', () => {
          if (!modeModelState[currentMode]) {
            modeModelState[currentMode] = { primary: '', fallback: '' };
          }
          if (!fallbackModelSelect.disabled) {
            modeModelState[currentMode].fallback = fallbackModelSelect.value || '';
          }
        });
      }

      if (setSpreadsheetButton) {
        setSpreadsheetButton.addEventListener('click', () => {
          void handleSpreadsheetSet();
        });
      }

      if (spreadsheetUrlInput) {
        spreadsheetUrlInput.addEventListener('input', () => {
          if (autoCheckTimer) {
            clearTimeout(autoCheckTimer);
            autoCheckTimer = null;
          }
          resolvedSpreadsheetId = '';
          resolvedSheets = [];
          clearSheetSelections('Setで読み込んでください');
        });
      }

      if (sheetKeywordInput) {
        sheetKeywordInput.addEventListener('change', () => {
          updateSheetSelectionInputs();
          markValidationDirty();
          attemptAutoCheck();
        });
      }

      if (scoreSheetKeywordInput) {
        scoreSheetKeywordInput.addEventListener('change', () => {
          updateSheetSelectionInputs();
          syncAnalysisSheetSelection();
          markValidationDirty();
          attemptAutoCheck();
        });
      }

      batchSizeInput.addEventListener('change', () => {
        if (!nonSSRState[currentMode]) {
          nonSSRState[currentMode] = {};
        }
        nonSSRState[currentMode].batchSize = batchSizeInput.value;
      });
      if (maxCategoryInput) {
        maxCategoryInput.addEventListener('change', () => {
          if (!nonSSRState[currentMode]) {
            nonSSRState[currentMode] = {};
          }
          nonSSRState[currentMode].maxCategoryCols = maxCategoryInput.value;
        });
      }
      concurrencyInput.addEventListener('change', () => {
        if (!nonSSRState[currentMode]) {
          nonSSRState[currentMode] = {};
        }
        nonSSRState[currentMode].concurrency = concurrencyInput.value;
      });
      timeoutInput.addEventListener('change', () => {
        if (!nonSSRState[currentMode]) {
          nonSSRState[currentMode] = {};
        }
        nonSSRState[currentMode].timeout = timeoutInput.value;
      });

      handleSSRChange();

      // Settings status
      const kf = document.getElementById('keys-form');
      kf.addEventListener('submit', async (e)=>{
        e.preventDefault();
        const fd = new FormData(kf);
        fd.set('persist', document.getElementById('persist').checked ? 'true' : 'false');
        const r = await fetch('/settings', { method:'POST', body: fd });
        if(!r.ok){
          showQueueToast('APIキー保存に失敗しました', { state: 'error' });
          return;
        }
        showQueueToast('APIキーを反映しました', { state: 'success' });
      });

      const form = jobForm;

      [spreadsheetUrlInput, sheetKeywordInput, scoreSheetKeywordInput].forEach((input) => {
        if (!input) return;
        input.addEventListener('input', () => markValidationDirty());
        input.addEventListener('change', () => markValidationDirty());
      });

      if (checkStatusButton) {
        checkStatusButton.addEventListener('click', async (e) => {
          e.preventDefault();
          const url = spreadsheetUrlInput.value.trim();
          const sheetValue = getAnalysisSheetKeyword();
          const scoreValue = getScoreSheetKeyword();
          const ssrEnabled = isSSREnabled();
          if (!url) {
            const message = 'スプレッドシートURLを入力してください。';
            showValidationBanner('error', message);
            setValidationResult(false, null, message, 'error');
            return;
          }
          if (!resolvedSpreadsheetId) {
            const message = 'Setボタンでシート一覧を読み込み、シートを選択してください。';
            showValidationBanner('error', message);
            setValidationResult(false, null, message, 'error');
            return;
          }
          if (!sheetValue) {
            const message = ssrEnabled ? '分析テキストのシートを選択してください。' : 'スコア出力のシートを選択してください。';
            showValidationBanner('error', message);
            setValidationResult(false, null, message, 'error');
            return;
          }
          if (ssrEnabled && sheetKeywordInput?.disabled) {
            const message = '分析テキストのシートを選択してください。';
            showValidationBanner('error', message);
            setValidationResult(false, null, message, 'error');
            return;
          }
          if (!scoreValue || scoreSheetKeywordInput.disabled) {
            const message = 'スコア出力のシートを選択してください。';
            showValidationBanner('error', message);
            setValidationResult(false, null, message, 'error');
            return;
          }
          await performSheetCheck({ auto: false });
        });
      }

      setValidationResult(false, null, 'Setでシートを読み込み、ドロップダウンからシートを選択してください。', 'info');

      async function handleQueueAdd(event) {
        event.preventDefault();
        if(!isValidationCurrent()){
          showValidationBanner('error', 'シート設定の検証を完了してください（Set→シート選択で自動検証）。');
          return;
        }
        const button = event.currentTarget instanceof HTMLElement ? event.currentTarget : null;
        const releaseBusy = button ? setButtonBusy(button, '追加中...') : null;
        try {
          await loadingOverlay.requireKeys();
          const fd = buildJobFormData('queue');
          const res = await fetch('/jobs', { method: 'POST', body: fd });
          if (!res.ok) {
            showQueueToast('キュー追加に失敗', { state: 'error' });
            return;
          }
          await refreshQueue();
          showQueueToast('キューに追加しました', { state: 'success' });
        } finally {
          if (releaseBusy) releaseBusy();
          updateQueueActionState();
        }
      }

      if (queueAddButton) {
        queueAddButton.addEventListener('click', handleQueueAdd);
      }

      if (queueAddActionButton) {
        queueAddActionButton.addEventListener('click', handleQueueAdd);
      }

      if (queueAddStartButton) {
        queueAddStartButton.addEventListener('click', async (e) => {
          e.preventDefault();
          if(!isValidationCurrent()){
            showValidationBanner('error', 'シート設定の検証を完了してください（Set→シート選択で自動検証）。');
            return;
          }
          const releaseButton = setButtonBusy(queueAddStartButton, '実行中...');
          lockActionButtons(true);
          showValidationBanner('info', 'ジョブを開始しています。数秒お待ちください...');
          try {
            await runWithOverlay(async () => {
              const fd = buildJobFormData('start');
              const res = await fetch('/jobs', { method: 'POST', body: fd });
              if (!res.ok) {
                let message = '開始に失敗しました。設定を確認してください。';
                try {
                  const errJson = await res.json();
                  if (errJson?.detail) {
                    message = Array.isArray(errJson.detail)
                      ? errJson.detail.map((d) => d.msg || '').join(' ')
                      : String(errJson.detail);
                  }
                } catch {}
                showValidationBanner('error', message);
                throw new Error(message);
              }
              const data = await res.json();
              currentJobId = data.job_id;
              resultSection.style.display = 'block';
              document.getElementById('job-id').textContent = currentJobId;
              resetLogView();
              await ensureQueueRunning();
              startPolling(currentJobId);
              showValidationBanner('success', 'ジョブを開始しました。右側の進捗を確認できます。');
              await refreshQueue();
            });
          } catch (err) {
            if (err instanceof Error && err.message) {
              console.error('Failed to start job', err);
            }
          } finally {
            releaseButton();
            lockActionButtons(false);
            updateQueueActionState();
          }
        });
      }

      const queueStartButton = document.getElementById('btn-queue-start');
      if (queueStartButton) {
        queueStartButton.addEventListener('click', async ()=>{
          const release = setButtonBusy(queueStartButton, '起動中...');
          try {
            await runWithOverlay(async () => {
              await fetch('/queue/start', { method:'POST' });
              await refreshQueue();
            });
          } finally {
            release();
            updateQueueActionState();
          }
        });
      }

      cancelButton.addEventListener('click', async ()=>{
        if(!currentJobId) return;
        cancelButton.disabled = true;
        try {
          const res = await fetch(`/jobs/${currentJobId}/cancel`, { method: 'POST' });
          if (!res.ok) {
            showQueueToast('キャンセルに失敗しました', { state: 'error' });
          }
          await refreshQueue();
          await updateProgress(currentJobId);
        } finally {
          cancelButton.disabled = false;
        }
      });

      async function refreshQueue(){
        try{
          const r = await fetch('/queue');
          if(!r.ok) return;
          const j = await r.json();
          const list = document.getElementById('queue-list');
          list.innerHTML = '';
          const items = j.items || [];
          const runningId = j.current;
          if (queueStatus) {
            queueStatus.innerHTML = '';
            if (j.running) {
              const label = document.createElement('span');
              label.className = 'queue-status-label';
              label.textContent = '稼働中';
              const dot = document.createElement('span');
              dot.className = 'queue-status-dot queue-status-dot--active';
              const chip = document.createElement('span');
              chip.className = 'queue-chip queue-chip--active';
              chip.textContent = runningId || '実行中';
              queueStatus.appendChild(label);
              queueStatus.appendChild(dot);
              queueStatus.appendChild(chip);
            } else {
              const label = document.createElement('span');
              label.className = 'queue-status-label';
              label.textContent = '待機中';
              const dot = document.createElement('span');
              dot.className = 'queue-status-dot queue-status-dot--idle';
              queueStatus.appendChild(label);
              queueStatus.appendChild(dot);
            }
          }
          if (runningId) {
            currentJobId = runningId;
            resultSection.style.display = 'block';
            document.getElementById('job-id').textContent = runningId;
            cancelButton.style.display = 'inline-flex';
            startPolling(runningId);
          } else {
            cancelButton.style.display = 'none';
            currentJobId = null;
            stopPolling();
          }
          items.forEach((it, idx)=>{
            const row = document.createElement('div');
            row.className = 'row';
            row.style.alignItems = 'center';
            row.innerHTML = `<code>${it.job_id}</code> <span class="muted">[${it.mode}]</span> <span>${it.sheet_name||''}</span> <span class="muted">status: ${it.status}</span>`;
            const right = document.createElement('div');
            right.className = 'right queue-actions';

            const up = document.createElement('button'); up.className='btn btn-ghost'; up.textContent='↑';
            up.onclick = async ()=>{ const pos = Math.max(0, idx-1); const fd=new FormData(); fd.set('position', pos); await fetch(`/queue/${it.job_id}/move`, {method:'POST', body:fd}); refreshQueue(); };
            const down = document.createElement('button'); down.className='btn btn-ghost'; down.textContent='↓';
            down.onclick = async ()=>{ const pos = idx+1; const fd=new FormData(); fd.set('position', pos); await fetch(`/queue/${it.job_id}/move`, {method:'POST', body:fd}); refreshQueue(); };
            const edit = document.createElement('button');
            edit.className = 'btn btn-soft-accent queue-edit-button';
            edit.setAttribute('aria-label', '編集');
            edit.textContent = '✎';
            edit.onclick = async ()=>{
              try{
                const r = await fetch(`/jobs/${it.job_id}/config`);
                if(!r.ok){
                  showQueueToast('設定取得に失敗しました', { state: 'error' });
                  return;
                }
                const txt = await r.text();
                const cfg = JSON.parse(txt);
                // Populate form with cfg
                form.spreadsheet_url.value = cfg.spreadsheet_url;
                const targetSheetName = cfg.sheet_name || cfg.sheet_keyword || '';
                const targetScoreSheetName = cfg.score_sheet_name || cfg.score_sheet_keyword || '';
                const targetSheetGid = cfg.sheet_gid != null ? String(cfg.sheet_gid) : '';
                const targetScoreSheetGid = cfg.score_sheet_gid != null ? String(cfg.score_sheet_gid) : '';
                if (sheetGidInput) sheetGidInput.value = targetSheetGid;
                if (scoreSheetGidInput) scoreSheetGidInput.value = targetScoreSheetGid;
                await handleSpreadsheetSet();
                populateSheetOptions(resolvedSheets, {
                  analysisGid: targetSheetGid,
                  analysisName: targetSheetName,
                  scoreGid: targetScoreSheetGid,
                  scoreName: targetScoreSheetName,
                });
                updateSheetSelectionInputs();
                attemptAutoCheck();
                form.utterance_col.value = cfg.utterance_col;
                form.category_start_col.value = cfg.category_start_col;
                form.name_row.value = cfg.name_row;
                form.def_row.value = cfg.def_row;
                form.detail_row.value = cfg.detail_row;
                form.start_row.value = cfg.start_row;
                form.batch_size.value = cfg.batch_size;
                form.max_category_cols.value = cfg.max_category_cols;
                form.concurrency.value = cfg.concurrency;
                form.max_retries.value = cfg.max_retries;
                if (autoSlowdownToggle) {
                  autoSlowdownToggle.checked = !!cfg.auto_slowdown;
                }
                form.timeout_sec.value = cfg.timeout_sec;
                document.querySelector(`#mode-form input[name="mode"][value="${cfg.mode}"]`).checked = true;
                enableSSR.checked = cfg.enable_ssr !== false;
                currentMode = cfg.mode || 'csv';
                if (!modeModelState[currentMode]) {
                  modeModelState[currentMode] = { primary: '', fallback: '' };
                }
                if (primaryModelSelect) {
                  const primaryValue = cfg.primary_model || MODE_DEFAULTS[currentMode].primaryModel;
                  if (primaryValue && primaryModelSelect.querySelector(`option[value="${primaryValue}"]`)) {
                    primaryModelSelect.value = primaryValue;
                  }
                  modeModelState[currentMode].primary = primaryModelSelect.value || '';
                }
                if (fallbackModelSelect) {
                  let fallbackValue = cfg.fallback_model;
                  if (currentMode === 'video') {
                    fallbackValue = '';
                  } else if (!fallbackValue) {
                    fallbackValue = MODE_DEFAULTS[currentMode].fallbackModel;
                  }
                  if (fallbackValue && fallbackModelSelect.querySelector(`option[value="${fallbackValue}"]`)) {
                    fallbackModelSelect.value = fallbackValue;
                  } else {
                    fallbackModelSelect.value = fallbackValue || '';
                  }
                  modeModelState[currentMode].fallback = fallbackModelSelect.value || '';
                }
                if (systemPromptSSRInput) {
                  systemPromptSSRInput.value = cfg.ssr_system_prompt || '';
                }
                if (systemPromptNumericInput) {
                  systemPromptNumericInput.value = cfg.numeric_system_prompt || '';
                }
                applyMode(currentMode);
                form.dataset.editing = it.job_id;
                showQueueToast('フォームに読み込みました。下の「編集を保存」で反映できます。', { state: 'info' });
                validation.markDirty(false);
                showValidationBanner('info', '読み込んだ設定です。シート検証を再実行してください。');
                validation.updateCard('info', '読み込んだ設定です。Set→シート選択で検証を完了してください。', null);
                updateQueueActionState();
              }catch{}
            };
            const save = document.createElement('button'); save.className='btn btn-primary queue-save-button'; save.textContent='編集を保存';
            save.onclick = async ()=>{
              const ej = form.dataset.editing;
              if(!ej){
                showQueueToast('編集対象が読み込まれていません', { state: 'error' });
                return;
              }
              const fd = buildJobFormData();
              const r = await fetch(`/queue/${ej}/edit`, { method:'POST', body: fd });
              if(!r.ok){
                showQueueToast('保存に失敗しました', { state: 'error' });
                return;
              }
              showQueueToast('保存しました', { state: 'success' });
              form.dataset.editing='';
              refreshQueue();
            };
            const del = document.createElement('button');
            del.className = 'btn btn-danger queue-delete-button';
            del.setAttribute('aria-label', '削除');
            del.textContent = '✕';
            del.onclick = async ()=>{ await fetch(`/queue/${it.job_id}`, { method:'DELETE' }); refreshQueue(); };

            right.appendChild(up); right.appendChild(down); right.appendChild(edit); right.appendChild(save); right.appendChild(del);
            row.appendChild(right);
            list.appendChild(row);
          });
        }catch{}
      }

      // 初期ロード
      refreshQueue();
      setInterval(refreshQueue, 2000);

      // ログUI廃止
    </script>
  </body>
  </html>
